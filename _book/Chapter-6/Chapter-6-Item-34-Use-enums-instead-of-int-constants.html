
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Item 34: Use enums instead of int constants（用枚举类型代替 int 常量） · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals.html" />
    
    
    <link rel="prev" href="Chapter-6-Introduction.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../Chapter-2/Chapter-2-Introduction.html">
            
                <a href="../Chapter-2/Chapter-2-Introduction.html">
            
                    
                    Chapter 2. Creating and Destroying Objects（创建和销毁对象）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../Chapter-2/Chapter-2-Introduction.html">
            
                <a href="../Chapter-2/Chapter-2-Introduction.html">
            
                    
                    Chapter 2 Introduction（章节介绍）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.html">
            
                <a href="../Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.html">
            
                    
                    Item 1: Consider static factory methods instead of constructors（考虑以静态工厂方法代替构造函数）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../Chapter-2/Chapter-2-Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters.html">
            
                <a href="../Chapter-2/Chapter-2-Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters.html">
            
                    
                    Item 2: Consider a builder when faced with many constructor parameters（在面对多个构造函数参数时，请考虑构建器）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type.html">
            
                <a href="../Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type.html">
            
                    
                    Item 3: Enforce the singleton property with a private constructor or an enum type（使用私有构造函数或枚举类型实施单例属性）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../Chapter-2/Chapter-2-Item-4-Enforce-noninstantiability-with-a-private-constructor.html">
            
                <a href="../Chapter-2/Chapter-2-Item-4-Enforce-noninstantiability-with-a-private-constructor.html">
            
                    
                    Item 4: Enforce noninstantiability with a private constructor（用私有构造函数实施不可实例化）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../Chapter-2/Chapter-2-Item-5-Prefer-dependency-injection-to-hardwiring-resources.html">
            
                <a href="../Chapter-2/Chapter-2-Item-5-Prefer-dependency-injection-to-hardwiring-resources.html">
            
                    
                    Item 5: Prefer dependency injection to hardwiring resources（依赖注入优于硬连接资源）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="../Chapter-2/Chapter-2-Item-6-Avoid-creating-unnecessary-objects.html">
            
                <a href="../Chapter-2/Chapter-2-Item-6-Avoid-creating-unnecessary-objects.html">
            
                    
                    Item 6: Avoid creating unnecessary objects（避免创建不必要的对象）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="../Chapter-2/Chapter-2-Item-7-Eliminate-obsolete-object-references.html">
            
                <a href="../Chapter-2/Chapter-2-Item-7-Eliminate-obsolete-object-references.html">
            
                    
                    Item 7: Eliminate obsolete object references（排除过时的对象引用）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="../Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.html">
            
                <a href="../Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.html">
            
                    
                    Item 8: Avoid finalizers and cleaners（避免使用终结器和清除器）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="../Chapter-2/Chapter-2-Item-9-Prefer-try-with-resources-to-try-finally.html">
            
                <a href="../Chapter-2/Chapter-2-Item-9-Prefer-try-with-resources-to-try-finally.html">
            
                    
                    Item 9: Prefer try with resources to try finally（使用 try-with-resources 优于 try-finally）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../Chapter-3/Chapter-3-Introduction.html">
            
                <a href="../Chapter-3/Chapter-3-Introduction.html">
            
                    
                    Chapter 3. Methods Common to All Objects（对象的通用方法）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../Chapter-3/Chapter-3-Introduction.html">
            
                <a href="../Chapter-3/Chapter-3-Introduction.html">
            
                    
                    Chapter 3 Introduction（章节介绍）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals.html">
            
                <a href="../Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals.html">
            
                    
                    Item 10: Obey the general contract when overriding equals（覆盖 equals 方法时应遵守的约定）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../Chapter-3/Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals.html">
            
                <a href="../Chapter-3/Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals.html">
            
                    
                    Item 11: Always override hashCode when you override equals（当覆盖 equals 方法时，总要覆盖 hashCode 方法）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../Chapter-3/Chapter-3-Item-12-Always-override-toString.html">
            
                <a href="../Chapter-3/Chapter-3-Item-12-Always-override-toString.html">
            
                    
                    Item 12: Always override toString（始终覆盖 toString 方法）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../Chapter-3/Chapter-3-Item-13-Override-clone-judiciously.html">
            
                <a href="../Chapter-3/Chapter-3-Item-13-Override-clone-judiciously.html">
            
                    
                    Item 13: Override clone judiciously（明智地覆盖 clone 方法）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../Chapter-3/Chapter-3-Item-14-Consider-implementing-Comparable.html">
            
                <a href="../Chapter-3/Chapter-3-Item-14-Consider-implementing-Comparable.html">
            
                    
                    Item 14: Consider implementing Comparable（考虑实现 Comparable 接口）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../Chapter-4/Chapter-4-Introduction.html">
            
                <a href="../Chapter-4/Chapter-4-Introduction.html">
            
                    
                    Chapter 4. Classes and Interfaces（类和接口）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../Chapter-4/Chapter-4-Introduction.html">
            
                <a href="../Chapter-4/Chapter-4-Introduction.html">
            
                    
                    Chapter 4 Introduction（章节介绍）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.html">
            
                <a href="../Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.html">
            
                    
                    Item 15: Minimize the accessibility of classes and members（尽量减少类和成员的可访问性）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../Chapter-4/Chapter-4-Item-16-In-public-classes-use-accessor-methods-not-public-fields.html">
            
                <a href="../Chapter-4/Chapter-4-Item-16-In-public-classes-use-accessor-methods-not-public-fields.html">
            
                    
                    Item 16: In public classes use accessor methods not public fields（在公共类中，使用访问器方法，而不是公共字段）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../Chapter-4/Chapter-4-Item-17-Minimize-mutability.html">
            
                <a href="../Chapter-4/Chapter-4-Item-17-Minimize-mutability.html">
            
                    
                    Item 17: Minimize mutability（减少可变性）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.html">
            
                <a href="../Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.html">
            
                    
                    Item 18: Favor composition over inheritance（优先选择复合而不是继承）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="../Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.html">
            
                <a href="../Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.html">
            
                    
                    Item 19: Design and document for inheritance or else prohibit it（继承要设计良好并且具有文档，否则禁止使用）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.7" data-path="../Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes.html">
            
                <a href="../Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes.html">
            
                    
                    Item 20: Prefer interfaces to abstract classes（接口优于抽象类）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.8" data-path="../Chapter-4/Chapter-4-Item-21-Design-interfaces-for-posterity.html">
            
                <a href="../Chapter-4/Chapter-4-Item-21-Design-interfaces-for-posterity.html">
            
                    
                    Item 21: Design interfaces for posterity（为后代设计接口）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.9" data-path="../Chapter-4/Chapter-4-Item-22-Use-interfaces-only-to-define-types.html">
            
                <a href="../Chapter-4/Chapter-4-Item-22-Use-interfaces-only-to-define-types.html">
            
                    
                    Item 22: Use interfaces only to define types（接口只用于定义类型）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.10" data-path="../Chapter-4/Chapter-4-Item-23-Prefer-class-hierarchies-to-tagged-classes.html">
            
                <a href="../Chapter-4/Chapter-4-Item-23-Prefer-class-hierarchies-to-tagged-classes.html">
            
                    
                    Item 23: Prefer class hierarchies to tagged classes（类层次结构优于带标签的类）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.11" data-path="../Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.html">
            
                <a href="../Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.html">
            
                    
                    Item 24: Favor static member classes over nonstatic（静态成员类优于非静态成员类）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.12" data-path="../Chapter-4/Chapter-4-Item-25-Limit-source-files-to-a-single-top-level-class.html">
            
                <a href="../Chapter-4/Chapter-4-Item-25-Limit-source-files-to-a-single-top-level-class.html">
            
                    
                    Item 25: Limit source files to a single top level class（源文件仅限有单个顶层类）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../Chapter-5/Chapter-5-Introduction.html">
            
                <a href="../Chapter-5/Chapter-5-Introduction.html">
            
                    
                    Chapter 5. Generics（泛型）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../Chapter-5/Chapter-5-Introduction.html">
            
                <a href="../Chapter-5/Chapter-5-Introduction.html">
            
                    
                    Chapter 5 Introduction（章节介绍）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.html">
            
                <a href="../Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.html">
            
                    
                    Item 26: Do not use raw types（不要使用原始类型）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings.html">
            
                <a href="../Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings.html">
            
                    
                    Item 27: Eliminate unchecked warnings（消除 unchecked 警告）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.html">
            
                <a href="../Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.html">
            
                    
                    Item 28: Prefer lists to arrays（list 优于数组）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../Chapter-5/Chapter-5-Item-29-Favor-generic-types.html">
            
                <a href="../Chapter-5/Chapter-5-Item-29-Favor-generic-types.html">
            
                    
                    Item 29: Favor generic types（优先使用泛型）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.6" data-path="../Chapter-5/Chapter-5-Item-30-Favor-generic-methods.html">
            
                <a href="../Chapter-5/Chapter-5-Item-30-Favor-generic-methods.html">
            
                    
                    Item 30: Favor generic methods（优先使用泛型方法）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.7" data-path="../Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.html">
            
                <a href="../Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.html">
            
                    
                    Item 31: Use bounded wildcards to increase API flexibility（使用有界通配符增加 API 的灵活性）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.8" data-path="../Chapter-5/Chapter-5-Item-32-Combine-generics-and-varargs-judiciously.html">
            
                <a href="../Chapter-5/Chapter-5-Item-32-Combine-generics-and-varargs-judiciously.html">
            
                    
                    Item 32: Combine generics and varargs judiciously（明智地合用泛型和可变参数）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.9" data-path="../Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers.html">
            
                <a href="../Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers.html">
            
                    
                    Item 33: Consider typesafe heterogeneous containers（考虑类型安全的异构容器）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="Chapter-6-Introduction.html">
            
                <a href="Chapter-6-Introduction.html">
            
                    
                    Chapter 6. Enums and Annotations（枚举和注解）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="Chapter-6-Introduction.html">
            
                <a href="Chapter-6-Introduction.html">
            
                    
                    Chapter 6 Introduction（章节介绍）
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.6.2" data-path="Chapter-6-Item-34-Use-enums-instead-of-int-constants.html">
            
                <a href="Chapter-6-Item-34-Use-enums-instead-of-int-constants.html">
            
                    
                    Item 34: Use enums instead of int constants（用枚举类型代替 int 常量）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals.html">
            
                <a href="Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals.html">
            
                    
                    Item 35: Use instance fields instead of ordinals（使用实例字段替代序数）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="Chapter-6-Item-36-Use-EnumSet-instead-of-bit-fields.html">
            
                <a href="Chapter-6-Item-36-Use-EnumSet-instead-of-bit-fields.html">
            
                    
                    Item 36: Use EnumSet instead of bit fields（用 EnumSet 替代位字段）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="Chapter-6-Item-37-Use-EnumMap-instead-of-ordinal-indexing.html">
            
                <a href="Chapter-6-Item-37-Use-EnumMap-instead-of-ordinal-indexing.html">
            
                    
                    Item 37: Use EnumMap instead of ordinal indexing（使用 EnumMap 替换序数索引）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces.html">
            
                <a href="Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces.html">
            
                    
                    Item 38: Emulate extensible enums with interfaces（使用接口模拟可扩展枚举）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="Chapter-6-Item-39-Prefer-annotations-to-naming-patterns.html">
            
                <a href="Chapter-6-Item-39-Prefer-annotations-to-naming-patterns.html">
            
                    
                    Item 39: Prefer annotations to naming patterns（注解优于命名模式）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.8" data-path="Chapter-6-Item-40-Consistently-use-the-Override-annotation.html">
            
                <a href="Chapter-6-Item-40-Consistently-use-the-Override-annotation.html">
            
                    
                    Item 40: Consistently use the Override annotation（坚持使用 @Override 注解）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.9" data-path="Chapter-6-Item-41-Use-marker-interfaces-to-define-types.html">
            
                <a href="Chapter-6-Item-41-Use-marker-interfaces-to-define-types.html">
            
                    
                    Item 41: Use marker interfaces to define types（使用标记接口定义类型）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../Chapter-7/Chapter-7-Introduction.html">
            
                <a href="../Chapter-7/Chapter-7-Introduction.html">
            
                    
                    Chapter 7. Lambdas and Streams（λ 表达式和流）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../Chapter-7/Chapter-7-Introduction.html">
            
                <a href="../Chapter-7/Chapter-7-Introduction.html">
            
                    
                    Chapter 7 Introduction（章节介绍）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes.html">
            
                <a href="../Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes.html">
            
                    
                    Item 42: Prefer lambdas to anonymous classes（λ 表达式优于匿名类）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../Chapter-7/Chapter-7-Item-43-Prefer-method-references-to-lambdas.html">
            
                <a href="../Chapter-7/Chapter-7-Item-43-Prefer-method-references-to-lambdas.html">
            
                    
                    Item 43: Prefer method references to lambdas（方法引用优于 λ 表达式）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../Chapter-7/Chapter-7-Item-44-Favor-the-use-of-standard-functional-interfaces.html">
            
                <a href="../Chapter-7/Chapter-7-Item-44-Favor-the-use-of-standard-functional-interfaces.html">
            
                    
                    Item 44: Favor the use of standard functional interfaces（优先使用标准函数式接口）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../Chapter-7/Chapter-7-Item-45-Use-streams-judiciously.html">
            
                <a href="../Chapter-7/Chapter-7-Item-45-Use-streams-judiciously.html">
            
                    
                    Item 45: Use streams judiciously（明智地使用流）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../Chapter-7/Chapter-7-Item-46-Prefer-side-effect-free-functions-in-streams.html">
            
                <a href="../Chapter-7/Chapter-7-Item-46-Prefer-side-effect-free-functions-in-streams.html">
            
                    
                    Item 46: Prefer side effect free functions in streams（在流中使用无副作用的函数）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7" data-path="../Chapter-7/Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type.html">
            
                <a href="../Chapter-7/Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type.html">
            
                    
                    Item 47: Prefer Collection to Stream as a return type（优先选择 Collection 而不是流作为返回类型）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.8" data-path="../Chapter-7/Chapter-7-Item-48-Use-caution-when-making-streams-parallel.html">
            
                <a href="../Chapter-7/Chapter-7-Item-48-Use-caution-when-making-streams-parallel.html">
            
                    
                    Item 48: Use caution when making streams parallel（谨慎使用并行流）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../Chapter-8/Chapter-8-Introduction.html">
            
                <a href="../Chapter-8/Chapter-8-Introduction.html">
            
                    
                    Chapter 8. Methods（方法）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../Chapter-8/Chapter-8-Introduction.html">
            
                <a href="../Chapter-8/Chapter-8-Introduction.html">
            
                    
                    Chapter 8 Introduction（章节介绍）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../Chapter-8/Chapter-8-Item-49-Check-parameters-for-validity.html">
            
                <a href="../Chapter-8/Chapter-8-Item-49-Check-parameters-for-validity.html">
            
                    
                    Item 49: Check parameters for validity（检查参数的有效性）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.html">
            
                <a href="../Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.html">
            
                    
                    Item 50: Make defensive copies when needed（在需要时制作防御性副本）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4" data-path="../Chapter-8/Chapter-8-Item-51-Design-method-signatures-carefully.html">
            
                <a href="../Chapter-8/Chapter-8-Item-51-Design-method-signatures-carefully.html">
            
                    
                    Item 51: Design method signatures carefully（仔细设计方法签名）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5" data-path="../Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously.html">
            
                <a href="../Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously.html">
            
                    
                    Item 52: Use overloading judiciously（明智地使用重载）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.6" data-path="../Chapter-8/Chapter-8-Item-53-Use-varargs-judiciously.html">
            
                <a href="../Chapter-8/Chapter-8-Item-53-Use-varargs-judiciously.html">
            
                    
                    Item 53: Use varargs judiciously（明智地使用可变参数）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.7" data-path="../Chapter-8/Chapter-8-Item-54-Return-empty-collections-or-arrays-not-nulls.html">
            
                <a href="../Chapter-8/Chapter-8-Item-54-Return-empty-collections-or-arrays-not-nulls.html">
            
                    
                    Item 54: Return empty collections or arrays, not nulls（返回空集合或数组，而不是 null）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.8" data-path="../Chapter-8/Chapter-8-Item-55-Return-optionals-judiciously.html">
            
                <a href="../Chapter-8/Chapter-8-Item-55-Return-optionals-judiciously.html">
            
                    
                    Item 55: Return optionals judiciously（明智地的返回 Optional）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.9" data-path="../Chapter-8/Chapter-8-Item-56-Write-doc-comments-for-all-exposed-API-elements.html">
            
                <a href="../Chapter-8/Chapter-8-Item-56-Write-doc-comments-for-all-exposed-API-elements.html">
            
                    
                    Item 56: Write doc comments for all exposed API elements（为所有公开的 API 元素编写文档注释）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../Chapter-9/Chapter-9-Introduction.html">
            
                <a href="../Chapter-9/Chapter-9-Introduction.html">
            
                    
                    Chapter 9. General Programming（通用程序设计）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../Chapter-9/Chapter-9-Introduction.html">
            
                <a href="../Chapter-9/Chapter-9-Introduction.html">
            
                    
                    Chapter 9 Introduction（章节介绍）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="../Chapter-9/Chapter-9-Item-57-Minimize-the-scope-of-local-variables.html">
            
                <a href="../Chapter-9/Chapter-9-Item-57-Minimize-the-scope-of-local-variables.html">
            
                    
                    Item 57: Minimize the scope of local variables（将局部变量的作用域最小化）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../Chapter-9/Chapter-9-Item-58-Prefer-for-each-loops-to-traditional-for-loops.html">
            
                <a href="../Chapter-9/Chapter-9-Item-58-Prefer-for-each-loops-to-traditional-for-loops.html">
            
                    
                    Item 58: Prefer for-each loops to traditional for loops（for-each 循环优于传统的 for 循环）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="../Chapter-9/Chapter-9-Item-59-Know-and-use-the-libraries.html">
            
                <a href="../Chapter-9/Chapter-9-Item-59-Know-and-use-the-libraries.html">
            
                    
                    Item 59: Know and use the libraries（了解并使用库）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="../Chapter-9/Chapter-9-Item-60-Avoid-float-and-double-if-exact-answers-are-required.html">
            
                <a href="../Chapter-9/Chapter-9-Item-60-Avoid-float-and-double-if-exact-answers-are-required.html">
            
                    
                    Item 60: Avoid float and double if exact answers are required（若需要精确答案就应避免使用 float 和 double 类型）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6" data-path="../Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives.html">
            
                <a href="../Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives.html">
            
                    
                    Item 61: Prefer primitive types to boxed primitives（基本数据类型优于包装类）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.7" data-path="../Chapter-9/Chapter-9-Item-62-Avoid-strings-where-other-types-are-more-appropriate.html">
            
                <a href="../Chapter-9/Chapter-9-Item-62-Avoid-strings-where-other-types-are-more-appropriate.html">
            
                    
                    Item 62: Avoid strings where other types are more appropriate（其他类型更合适时应避免使用字符串）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.8" data-path="../Chapter-9/Chapter-9-Item-63-Beware-the-performance-of-string-concatenation.html">
            
                <a href="../Chapter-9/Chapter-9-Item-63-Beware-the-performance-of-string-concatenation.html">
            
                    
                    Item 63: Beware the performance of string concatenation（当心字符串连接引起的性能问题）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.9" data-path="../Chapter-9/Chapter-9-Item-64-Refer-to-objects-by-their-interfaces.html">
            
                <a href="../Chapter-9/Chapter-9-Item-64-Refer-to-objects-by-their-interfaces.html">
            
                    
                    Item 64: Refer to objects by their interfaces（通过接口引用对象）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.10" data-path="../Chapter-9/Chapter-9-Item-65-Prefer-interfaces-to-reflection.html">
            
                <a href="../Chapter-9/Chapter-9-Item-65-Prefer-interfaces-to-reflection.html">
            
                    
                    Item 65: Prefer interfaces to reflection（接口优于反射）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.11" data-path="../Chapter-9/Chapter-9-Item-66-Use-native-methods-judiciously.html">
            
                <a href="../Chapter-9/Chapter-9-Item-66-Use-native-methods-judiciously.html">
            
                    
                    Item 66: Use native methods judiciously（明智地使用本地方法）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.12" data-path="../Chapter-9/Chapter-9-Item-67-Optimize-judiciously.html">
            
                <a href="../Chapter-9/Chapter-9-Item-67-Optimize-judiciously.html">
            
                    
                    Item 67: Optimize judiciously（明智地进行优化）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.13" data-path="../Chapter-9/Chapter-9-Item-68-Adhere-to-generally-accepted-naming-conventions.html">
            
                <a href="../Chapter-9/Chapter-9-Item-68-Adhere-to-generally-accepted-naming-conventions.html">
            
                    
                    Item 68: Adhere to generally accepted naming conventions（遵守被广泛认可的命名约定）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../Chapter-10/Chapter-10-Introduction.html">
            
                <a href="../Chapter-10/Chapter-10-Introduction.html">
            
                    
                    Chapter 10. Exceptions（异常）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="../Chapter-10/Chapter-10-Introduction.html">
            
                <a href="../Chapter-10/Chapter-10-Introduction.html">
            
                    
                    Chapter 10 Introduction（章节介绍）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="../Chapter-10/Chapter-10-Item-69-Use-exceptions-only-for-exceptional-conditions.html">
            
                <a href="../Chapter-10/Chapter-10-Item-69-Use-exceptions-only-for-exceptional-conditions.html">
            
                    
                    Item 69: Use exceptions only for exceptional conditions（仅在确有异常条件下使用异常）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="../Chapter-10/Chapter-10-Item-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors.html">
            
                <a href="../Chapter-10/Chapter-10-Item-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors.html">
            
                    
                    Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors（对可恢复情况使用 checked 异常，对编程错误使用运行时异常）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="../Chapter-10/Chapter-10-Item-71-Avoid-unnecessary-use-of-checked-exceptions.html">
            
                <a href="../Chapter-10/Chapter-10-Item-71-Avoid-unnecessary-use-of-checked-exceptions.html">
            
                    
                    Item 71: Avoid unnecessary use of checked exceptions（避免不必要地使用 checked 异常）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="../Chapter-10/Chapter-10-Item-72-Favor-the-use-of-standard-exceptions.html">
            
                <a href="../Chapter-10/Chapter-10-Item-72-Favor-the-use-of-standard-exceptions.html">
            
                    
                    Item 72: Favor the use of standard exceptions（鼓励复用标准异常）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.6" data-path="../Chapter-10/Chapter-10-Item-73-Throw-exceptions-appropriate-to-the-abstraction.html">
            
                <a href="../Chapter-10/Chapter-10-Item-73-Throw-exceptions-appropriate-to-the-abstraction.html">
            
                    
                    Item 73: Throw exceptions appropriate to the abstraction（抛出能用抽象解释的异常）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.7" data-path="../Chapter-10/Chapter-10-Item-74-Document-all-exceptions-thrown-by-each-method.html">
            
                <a href="../Chapter-10/Chapter-10-Item-74-Document-all-exceptions-thrown-by-each-method.html">
            
                    
                    Item 74: Document all exceptions thrown by each method（为每个方法记录会抛出的所有异常）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.8" data-path="../Chapter-10/Chapter-10-Item-75-Include-failure-capture-information-in-detail-messages.html">
            
                <a href="../Chapter-10/Chapter-10-Item-75-Include-failure-capture-information-in-detail-messages.html">
            
                    
                    Item 75: Include failure capture information in detail messages（异常详细消息中应包含捕获失败的信息）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.9" data-path="../Chapter-10/Chapter-10-Item-76-Strive-for-failure-atomicity.html">
            
                <a href="../Chapter-10/Chapter-10-Item-76-Strive-for-failure-atomicity.html">
            
                    
                    Item 76: Strive for failure atomicity（尽力保证故障原子性）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.10" data-path="../Chapter-10/Chapter-10-Item-77-Don’t-ignore-exceptions.html">
            
                <a href="../Chapter-10/Chapter-10-Item-77-Don’t-ignore-exceptions.html">
            
                    
                    Item 77: Don’t ignore exceptions（不要忽略异常）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../Chapter-11/Chapter-11-Introduction.html">
            
                <a href="../Chapter-11/Chapter-11-Introduction.html">
            
                    
                    Chapter 11. Concurrency（并发）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="../Chapter-11/Chapter-11-Introduction.html">
            
                <a href="../Chapter-11/Chapter-11-Introduction.html">
            
                    
                    Chapter 11 Introduction（章节介绍）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="../Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.html">
            
                <a href="../Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.html">
            
                    
                    Item 78: Synchronize access to shared mutable data（对共享可变数据的同步访问）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="../Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization.html">
            
                <a href="../Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization.html">
            
                    
                    Item 79: Avoid excessive synchronization（避免过度同步）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.4" data-path="../Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads.html">
            
                <a href="../Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads.html">
            
                    
                    Item 80: Prefer executors, tasks, and streams to threads（Executor、task、流优于直接使用线程）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.5" data-path="../Chapter-11/Chapter-11-Item-81-Prefer-concurrency-utilities-to-wait-and-notify.html">
            
                <a href="../Chapter-11/Chapter-11-Item-81-Prefer-concurrency-utilities-to-wait-and-notify.html">
            
                    
                    Item 81: Prefer concurrency utilities to wait and notify（并发实用工具优于 wait 和 notify）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.6" data-path="../Chapter-11/Chapter-11-Item-82-Document-thread-safety.html">
            
                <a href="../Chapter-11/Chapter-11-Item-82-Document-thread-safety.html">
            
                    
                    Item 82: Document thread safety（文档应包含线程安全属性）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.7" data-path="../Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously.html">
            
                <a href="../Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously.html">
            
                    
                    Item 83: Use lazy initialization judiciously（明智地使用延迟初始化）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.8" data-path="../Chapter-11/Chapter-11-Item-84-Don’t-depend-on-the-thread-scheduler.html">
            
                <a href="../Chapter-11/Chapter-11-Item-84-Don’t-depend-on-the-thread-scheduler.html">
            
                    
                    Item 84: Don’t depend on the thread scheduler（不要依赖线程调度器）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="../Chapter-12/Chapter-12-Introduction.html">
            
                <a href="../Chapter-12/Chapter-12-Introduction.html">
            
                    
                    Chapter 12. Serialization（序列化）
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="../Chapter-12/Chapter-12-Introduction.html">
            
                <a href="../Chapter-12/Chapter-12-Introduction.html">
            
                    
                    Chapter 12 Introduction（章节介绍）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="../Chapter-12/Chapter-12-Item-85-Prefer-alternatives-to-Java-serialization.html">
            
                <a href="../Chapter-12/Chapter-12-Item-85-Prefer-alternatives-to-Java-serialization.html">
            
                    
                    Item 85: Prefer alternatives to Java serialization（Java 序列化的替代方案）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="../Chapter-12/Chapter-12-Item-86-Implement-Serializable-with-great-caution.html">
            
                <a href="../Chapter-12/Chapter-12-Item-86-Implement-Serializable-with-great-caution.html">
            
                    
                    Item 86: Implement Serializable with great caution（非常谨慎地实现 Serializable）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.4" data-path="../Chapter-12/Chapter-12-Item-87-Consider-using-a-custom-serialized-form.html">
            
                <a href="../Chapter-12/Chapter-12-Item-87-Consider-using-a-custom-serialized-form.html">
            
                    
                    Item 87: Consider using a custom serialized form（考虑使用自定义序列化形式）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.5" data-path="../Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively.html">
            
                <a href="../Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively.html">
            
                    
                    Item 88: Write readObject methods defensively（防御性地编写 readObject 方法）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.6" data-path="../Chapter-12/Chapter-12-Item-89-For-instance-control-prefer-enum-types-to-readResolve.html">
            
                <a href="../Chapter-12/Chapter-12-Item-89-For-instance-control-prefer-enum-types-to-readResolve.html">
            
                    
                    Item 89: For instance control, prefer enum types to readResolve（对于实例控制，枚举类型优于 readResolve）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.7" data-path="../Chapter-12/Chapter-12-Item-90-Consider-serialization-proxies-instead-of-serialized-instances.html">
            
                <a href="../Chapter-12/Chapter-12-Item-90-Consider-serialization-proxies-instead-of-serialized-instances.html">
            
                    
                    Item 90: Consider serialization proxies instead of serialized instances（考虑以序列化代理代替序列化实例）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Item 34: Use enums instead of int constants（用枚举类型代替 int 常量）</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h2 id="chapter-6-enums-and-annotations&#xFF08;&#x679A;&#x4E3E;&#x548C;&#x6CE8;&#x89E3;&#xFF09;">Chapter 6. Enums and Annotations&#xFF08;&#x679A;&#x4E3E;&#x548C;&#x6CE8;&#x89E3;&#xFF09;</h2>
<h3 id="item-34-use-enums-instead-of-int-constants&#xFF08;&#x7528;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x4EE3;&#x66FF;-int-&#x5E38;&#x91CF;&#xFF09;">Item 34: Use enums instead of int constants&#xFF08;&#x7528;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x4EE3;&#x66FF; int &#x5E38;&#x91CF;&#xFF09;</h3>
<p>An enumerated type is a type whose legal values consist of a fixed set of constants, such as the seasons of the year, the planets in the solar system, or the suits in a deck of playing cards. Before enum types were added to the language, a common pattern for representing enumerated types was to declare a group of named int constants, one for each member of the type:</p>
<p>&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x662F;&#x8FD9;&#x6837;&#x4E00;&#x79CD;&#x7C7B;&#x578B;&#xFF1A;&#x5B83;&#x5408;&#x6CD5;&#x7684;&#x503C;&#x7531;&#x4E00;&#x7EC4;&#x56FA;&#x5B9A;&#x7684;&#x5E38;&#x91CF;&#x7EC4;&#x6210;&#xFF0C;&#x5982;&#xFF1A;&#x4E00;&#x5E74;&#x4E2D;&#x7684;&#x5B63;&#x8282;&#x3001;&#x592A;&#x9633;&#x7CFB;&#x4E2D;&#x7684;&#x884C;&#x661F;&#x6216;&#x6251;&#x514B;&#x724C;&#x4E2D;&#x7684;&#x82B1;&#x8272;&#x3002;&#x5728;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x88AB;&#x6DFB;&#x52A0;&#x5230; JAVA &#x4E4B;&#x524D;&#xFF0C;&#x8868;&#x793A;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x7684;&#x4E00;&#x79CD;&#x5E38;&#x89C1;&#x6A21;&#x5F0F;&#x662F;&#x58F0;&#x660E;&#x4E00;&#x7EC4; int &#x7684;&#x5E38;&#x91CF;&#xFF0C;&#x6BCF;&#x4E2A;&#x7C7B;&#x578B;&#x7684;&#x6210;&#x5458;&#x90FD;&#x6709;&#x4E00;&#x4E2A;&#xFF1A;</p>
<pre><code>// The int enum pattern - severely deficient!
public static final int APPLE_FUJI = 0;
public static final int APPLE_PIPPIN = 1;
public static final int APPLE_GRANNY_SMITH = 2;
public static final int ORANGE_NAVEL = 0;
public static final int ORANGE_TEMPLE = 1;
public static final int ORANGE_BLOOD = 2;
</code></pre><p>This technique, known as the int enum pattern, has many shortcomings. It provides nothing in the way of type safety and little in the way of expressive power. The compiler won&#x2019;t complain if you pass an apple to a method that expects an orange, compare apples to oranges with the == operator, or worse:</p>
<p>&#x8FD9;&#x79CD;&#x6280;&#x672F;&#x79F0;&#x4E3A; int &#x679A;&#x4E3E;&#x6A21;&#x5F0F;&#xFF0C;&#x5B83;&#x6709;&#x8BB8;&#x591A;&#x7F3A;&#x70B9;&#x3002;&#x5B83;&#x6CA1;&#x6709;&#x63D0;&#x4F9B;&#x4EFB;&#x4F55;&#x7C7B;&#x578B;&#x5B89;&#x5168;&#x6027;&#xFF0C;&#x5E76;&#x4E14;&#x51E0;&#x4E4E;&#x4E0D;&#x5177;&#x5907;&#x8868;&#x73B0;&#x529B;&#x3002;&#x5982;&#x679C;&#x4F60;&#x4F20;&#x9012;&#x4E00;&#x4E2A;&#x82F9;&#x679C;&#x7ED9;&#x65B9;&#x6CD5;&#xFF0C;&#x5E0C;&#x671B;&#x5F97;&#x5230;&#x4E00;&#x4E2A;&#x6A58;&#x5B50;&#xFF0C;&#x4F7F;&#x7528; == &#x64CD;&#x4F5C;&#x7B26;&#x6BD4;&#x8F83;&#x82F9;&#x679C;&#x548C;&#x6A58;&#x5B50;&#x65F6;&#x7F16;&#x8BD1;&#x5668;&#x5E76;&#x4E0D;&#x4F1A;&#x63D0;&#x793A;&#x9519;&#x8BEF;&#xFF0C;&#x6216;&#x66F4;&#x7CDF;&#x7684;&#x60C5;&#x51B5;&#xFF1A;</p>
<pre><code>// Tasty citrus flavored applesauce!
int i = (APPLE_FUJI - ORANGE_TEMPLE) / APPLE_PIPPIN;
</code></pre><p>Note that the name of each apple constant is prefixed with APPLE<em> and the name of each orange constant is prefixed with ORANGE</em>. This is because Java doesn&#x2019;t provide namespaces for int enum groups. Prefixes prevent name clashes when two int enum groups have identically named constants, for example between ELEMENT_MERCURY and PLANET_MERCURY.</p>
<p>&#x6CE8;&#x610F;&#xFF0C;&#x6BCF;&#x4E2A; apple &#x5E38;&#x91CF;&#x7684;&#x540D;&#x79F0;&#x90FD;&#x4EE5; APPLE<em> &#x4E3A;&#x524D;&#x7F00;&#xFF0C;&#x6BCF;&#x4E2A; orange &#x5E38;&#x91CF;&#x7684;&#x540D;&#x79F0;&#x90FD;&#x4EE5; ORANGE</em> &#x4E3A;&#x524D;&#x7F00;&#x3002;&#x8FD9;&#x662F;&#x56E0;&#x4E3A; Java &#x4E0D;&#x4E3A;&#x8FD9;&#x4E9B; int &#x679A;&#x4E3E;&#x63D0;&#x4F9B;&#x540D;&#x79F0;&#x7A7A;&#x95F4;&#x3002;&#x5F53;&#x4E24;&#x7EC4; int &#x679A;&#x4E3E;&#x5177;&#x6709;&#x76F8;&#x540C;&#x7684;&#x547D;&#x540D;&#x5E38;&#x91CF;&#x65F6;&#xFF0C;&#x524D;&#x7F00;&#x53EF;&#x4EE5;&#x9632;&#x6B62;&#x540D;&#x79F0;&#x51B2;&#x7A81;&#xFF0C;&#x4F8B;&#x5982; ELEMENT_MERCURY &#x548C; PLANET_MERCURY &#x4E4B;&#x95F4;&#x7684;&#x51B2;&#x7A81;&#x3002;</p>
<p>Programs that use int enums are brittle. Because int enums are constant variables [JLS, 4.12.4], their int values are compiled into the clients that use them [JLS, 13.1]. If the value associated with an int enum is changed, its clients must be recompiled. If not, the clients will still run, but their behavior will be incorrect.</p>
<p>&#x4F7F;&#x7528; int &#x679A;&#x4E3E;&#x7684;&#x7A0B;&#x5E8F;&#x5F88;&#x8106;&#x5F31;&#x3002;&#x56E0;&#x4E3A; int &#x679A;&#x4E3E;&#x662F;&#x5E38;&#x91CF;&#x53D8;&#x91CF; [JLS, 4.12.4]&#xFF0C;&#x6240;&#x4EE5;&#x5B83;&#x4EEC;&#x7684;&#x503C;&#x88AB;&#x7F16;&#x8BD1;&#x5230;&#x4F7F;&#x7528;&#x5B83;&#x4EEC;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x4E2D; [JLS, 13.1]&#x3002;&#x5982;&#x679C;&#x4E0E; int &#x679A;&#x4E3E;&#x5173;&#x8054;&#x7684;&#x503C;&#x53D1;&#x751F;&#x4E86;&#x66F4;&#x6539;&#xFF0C;&#x5219;&#x5FC5;&#x987B;&#x91CD;&#x65B0;&#x7F16;&#x8BD1;&#x5BA2;&#x6237;&#x7AEF;&#x3002;&#x5982;&#x679C;&#x4E0D;&#x91CD;&#x65B0;&#x7F16;&#x8BD1;&#xFF0C;&#x5BA2;&#x6237;&#x7AEF;&#x4ECD;&#x7136;&#x53EF;&#x4EE5;&#x8FD0;&#x884C;&#xFF0C;&#x4F46;&#x662F;&#x4ED6;&#x4EEC;&#x7684;&#x884C;&#x4E3A;&#x5C06;&#x662F;&#x9519;&#x8BEF;&#x7684;&#x3002;</p>
<p>There is no easy way to translate int enum constants into printable strings. If you print such a constant or display it from a debugger, all you see is a number, which isn&#x2019;t very helpful. There is no reliable way to iterate over all the int enum constants in a group, or even to obtain the size of an int enum group.</p>
<p>&#x6CA1;&#x6709;&#x4E00;&#x79CD;&#x7B80;&#x5355;&#x7684;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x5C06; int &#x679A;&#x4E3E;&#x5E38;&#x91CF;&#x8F6C;&#x6362;&#x4E3A;&#x53EF;&#x6253;&#x5370;&#x7684;&#x5B57;&#x7B26;&#x4E32;&#x3002;&#x5982;&#x679C;&#x4F60;&#x6253;&#x5370;&#x8FD9;&#x6837;&#x7684;&#x5E38;&#x91CF;&#x6216;&#x4ECE;&#x8C03;&#x8BD5;&#x5668;&#x4E2D;&#x663E;&#x793A;&#x5B83;&#xFF0C;&#x4F60;&#x6240;&#x770B;&#x5230;&#x7684;&#x53EA;&#x662F;&#x4E00;&#x4E2A;&#x6570;&#x5B57;&#xFF0C;&#x8FD9;&#x4E0D;&#x662F;&#x5F88;&#x6709;&#x5E2E;&#x52A9;&#x3002;&#x6CA1;&#x6709;&#x53EF;&#x9760;&#x7684;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x904D;&#x5386;&#x7EC4;&#x4E2D;&#x7684;&#x6240;&#x6709; int &#x679A;&#x4E3E;&#x5E38;&#x91CF;&#xFF0C;&#x751A;&#x81F3;&#x65E0;&#x6CD5;&#x83B7;&#x5F97;&#x7EC4;&#x7684;&#x5927;&#x5C0F;&#x3002;</p>
<p>You may encounter a variant of this pattern in which String constants are used in place of int constants. This variant, known as the String enum pattern, is even less desirable. While it does provide printable strings for its constants, it can lead naive users to hard-code string constants into client code instead of using field names. If such a hard-coded string constant contains a typographical error, it will escape detection at compile time and result in bugs at runtime. Also, it might lead to performance problems, because it relies on string comparisons.</p>
<p>&#x53EF;&#x80FD;&#x4F1A;&#x9047;&#x5230;&#x8FD9;&#x79CD;&#x6A21;&#x5F0F;&#x7684;&#x53E6;&#x4E00;&#x79CD;&#x5F62;&#x5F0F;&#xFF1A;&#x4F7F;&#x7528; String &#x5E38;&#x91CF;&#x4EE3;&#x66FF; int &#x5E38;&#x91CF;&#x3002;&#x8FD9;&#x79CD;&#x79F0;&#x4E3A; String &#x679A;&#x4E3E;&#x6A21;&#x5F0F;&#x7684;&#x53D8;&#x4F53;&#x751A;&#x81F3;&#x66F4;&#x4E0D;&#x53EF;&#x53D6;&#x3002;&#x867D;&#x7136;&#x5B83;&#x786E;&#x5B9E;&#x4E3A;&#x5E38;&#x91CF;&#x63D0;&#x4F9B;&#x4E86;&#x53EF;&#x6253;&#x5370;&#x7684;&#x5B57;&#x7B26;&#x4E32;&#xFF0C;&#x4F46;&#x662F;&#x5B83;&#x53EF;&#x80FD;&#x4F1A;&#x5BFC;&#x81F4;&#x4E0D;&#x77E5;&#x60C5;&#x7684;&#x7528;&#x6237;&#x5C06;&#x5B57;&#x7B26;&#x4E32;&#x5E38;&#x91CF;&#x786C;&#x7F16;&#x7801;&#x5230;&#x5BA2;&#x6237;&#x7AEF;&#x4EE3;&#x7801;&#x4E2D;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x4F7F;&#x7528;&#x5B57;&#x6BB5;&#x540D;&#x3002;&#x5982;&#x679C;&#x8FD9;&#x6837;&#x4E00;&#x4E2A;&#x786C;&#x7F16;&#x7801;&#x7684; String &#x5E38;&#x91CF;&#x5305;&#x542B;&#x4E00;&#x4E2A;&#x6392;&#x7248;&#x9519;&#x8BEF;&#xFF0C;&#x5B83;&#x5C06;&#x5728;&#x7F16;&#x8BD1;&#x65F6;&#x8EB2;&#x8FC7;&#x68C0;&#x6D4B;&#xFF0C;&#x5E76;&#x5728;&#x8FD0;&#x884C;&#x65F6;&#x5BFC;&#x81F4;&#x9519;&#x8BEF;&#x3002;&#x6B64;&#x5916;&#xFF0C;&#x5B83;&#x53EF;&#x80FD;&#x4F1A;&#x5BFC;&#x81F4;&#x6027;&#x80FD;&#x95EE;&#x9898;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4F9D;&#x8D56;&#x4E8E;&#x5B57;&#x7B26;&#x4E32;&#x6BD4;&#x8F83;&#x3002;</p>
<p>Luckily, Java provides an alternative that avoids all the shortcomings of the int and string enum patterns and provides many added benefits. It is the enum type [JLS, 8.9]. Here&#x2019;s how it looks in its simplest form:</p>
<p>&#x5E78;&#x8FD0;&#x7684;&#x662F;&#xFF0C;Java &#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x79CD;&#x66FF;&#x4EE3;&#x65B9;&#x6848;&#xFF0C;&#x5B83;&#x907F;&#x514D;&#x4E86; int &#x548C; String &#x679A;&#x4E3E;&#x6A21;&#x5F0F;&#x7684;&#x6240;&#x6709;&#x7F3A;&#x70B9;&#xFF0C;&#x5E76;&#x63D0;&#x4F9B;&#x4E86;&#x8BB8;&#x591A;&#x989D;&#x5916;&#x7684;&#x597D;&#x5904;&#x3002;&#x5B83;&#x5C31;&#x662F;&#x679A;&#x4E3E;&#x7C7B;&#x578B; [JLS, 8.9]&#x3002;&#x4E0B;&#x9762;&#x662F;&#x5B83;&#x6700;&#x7B80;&#x5355;&#x7684;&#x5F62;&#x5F0F;&#xFF1A;</p>
<pre><code>public enum Apple { FUJI, PIPPIN, GRANNY_SMITH }
public enum Orange { NAVEL, TEMPLE, BLOOD }
</code></pre><p>On the surface, these enum types may appear similar to those of other languages, such as C, C++, and C#, but appearances are deceiving. Java&#x2019;s enum types are full-fledged classes, far more powerful than their counterparts in these other languages, where enums are essentially int values.</p>
<p>&#x4ECE;&#x8868;&#x9762;&#x4E0A;&#x770B;&#xFF0C;&#x8FD9;&#x4E9B;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x53EF;&#x80FD;&#x4E0E;&#x5176;&#x4ED6;&#x8BED;&#x8A00;&#xFF08;&#x5982; C&#x3001;c++ &#x548C; c#&#xFF09;&#x7684;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x7C7B;&#x4F3C;&#xFF0C;&#x4F46;&#x4E0D;&#x80FD;&#x53EA;&#x770B;&#x8868;&#x8C61;&#x3002;Java &#x7684;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x662F;&#x6210;&#x719F;&#x7684;&#x7C7B;&#xFF0C;&#x6BD4;&#x5176;&#x4ED6;&#x8BED;&#x8A00;&#x4E2D;&#x7684;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x529F;&#x80FD;&#x5F3A;&#x5927;&#x5F97;&#x591A;&#xFF0C;&#x5728;&#x5176;&#x4ED6;&#x8BED;&#x8A00;&#x4E2D;&#x7684;&#x679A;&#x4E3E;&#x672C;&#x8D28;&#x4E0A;&#x662F; int &#x503C;&#x3002;</p>
<p>The basic idea behind Java&#x2019;s enum types is simple: they are classes that export one instance for each enumeration constant via a public static final field. Enum types are effectively final, by virtue of having no accessible constructors. Because clients can neither create instances of an enum type nor extend it, there can be no instances but the declared enum constants. In other words, enum types are instance-controlled (page 6). They are a generalization of singletons (Item 3), which are essentially single-element enums.</p>
<p>Java &#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x80CC;&#x540E;&#x7684;&#x57FA;&#x672C;&#x601D;&#x60F3;&#x5F88;&#x7B80;&#x5355;&#xFF1A;&#x5B83;&#x4EEC;&#x662F;&#x901A;&#x8FC7; public static final &#x4FEE;&#x9970;&#x7684;&#x5B57;&#x6BB5;&#x4E3A;&#x6BCF;&#x4E2A;&#x679A;&#x4E3E;&#x5E38;&#x91CF;&#x5BFC;&#x51FA;&#x4E00;&#x4E2A;&#x5B9E;&#x4F8B;&#x7684;&#x7C7B;&#x3002;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x5B9E;&#x9645;&#x4E0A;&#x662F; final &#x7C7B;&#x578B;&#xFF0C;&#x56E0;&#x4E3A;&#x6CA1;&#x6709;&#x53EF;&#x8BBF;&#x95EE;&#x7684;&#x6784;&#x9020;&#x51FD;&#x6570;&#x3002;&#x5BA2;&#x6237;&#x7AEF;&#x65E2;&#x4E0D;&#x80FD;&#x521B;&#x5EFA;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x7684;&#x5B9E;&#x4F8B;&#xFF0C;&#x4E5F;&#x4E0D;&#x80FD;&#x7EE7;&#x627F;&#x5B83;&#xFF0C;&#x6240;&#x4EE5;&#x9664;&#x4E86;&#x58F0;&#x660E;&#x7684;&#x679A;&#x4E3E;&#x5E38;&#x91CF;&#x4E4B;&#x5916;&#xFF0C;&#x4E0D;&#x80FD;&#x6709;&#x4EFB;&#x4F55;&#x5B9E;&#x4F8B;&#x3002;&#x6362;&#x53E5;&#x8BDD;&#x8BF4;&#xFF0C;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x662F;&#x5B9E;&#x4F8B;&#x53D7;&#x63A7;&#x7684;&#x7C7B;&#xFF08;&#x53C2;&#x9605;&#x7B2C; 6 &#x9875;&#xFF0C;<a href="../Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.html">Item-1</a>&#xFF09;&#x3002;&#x5B83;&#x4EEC;&#x662F;&#x5355;&#x4F8B;&#xFF08;<a href="../Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type.html">Item-3</a>&#xFF09;&#x7684;&#x63A8;&#x5E7F;&#x5E94;&#x7528;&#xFF0C;&#x5355;&#x4F8B;&#x672C;&#x8D28;&#x4E0A;&#x662F;&#x5355;&#x5143;&#x7D20;&#x7684;&#x679A;&#x4E3E;&#x3002;</p>
<p>Enums provide compile-time type safety. If you declare a parameter to be of type Apple, you are guaranteed that any non-null object reference passed to the parameter is one of the three valid Apple values. Attempts to pass values of the wrong type will result in compile-time errors, as will attempts to assign an expression of one enum type to a variable of another, or to use the == operator to compare values of different enum types.</p>
<p>&#x679A;&#x4E3E;&#x63D0;&#x4F9B;&#x7F16;&#x8BD1;&#x65F6;&#x7C7B;&#x578B;&#x7684;&#x5B89;&#x5168;&#x6027;&#x3002;&#x5982;&#x679C;&#x5C06;&#x53C2;&#x6570;&#x58F0;&#x660E;&#x4E3A; Apple &#x679A;&#x4E3E;&#x7C7B;&#x578B;&#xFF0C;&#x5219;&#x53EF;&#x4EE5;&#x4FDD;&#x8BC1;&#x4F20;&#x9012;&#x7ED9;&#x8BE5;&#x53C2;&#x6570;&#x7684;&#x4EFB;&#x4F55;&#x975E;&#x7A7A;&#x5BF9;&#x8C61;&#x5F15;&#x7528;&#x90FD;&#x662F;&#x4E09;&#x4E2A;&#x6709;&#x6548; Apple &#x679A;&#x4E3E;&#x503C;&#x4E4B;&#x4E00;&#x3002;&#x5C1D;&#x8BD5;&#x4F20;&#x9012;&#x9519;&#x8BEF;&#x7C7B;&#x578B;&#x7684;&#x503C;&#x5C06;&#x5BFC;&#x81F4;&#x7F16;&#x8BD1;&#x65F6;&#x9519;&#x8BEF;&#xFF0C;&#x5C06;&#x4E00;&#x4E2A;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x7684;&#x8868;&#x8FBE;&#x5F0F;&#x8D4B;&#x503C;&#x7ED9;&#x53E6;&#x4E00;&#x4E2A;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x7684;&#x53D8;&#x91CF;&#xFF0C;&#x6216;&#x8005;&#x4F7F;&#x7528; == &#x8FD0;&#x7B97;&#x7B26;&#x6BD4;&#x8F83;&#x4E0D;&#x540C;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x7684;&#x503C;&#x540C;&#x6837;&#x4F1A;&#x5BFC;&#x81F4;&#x9519;&#x8BEF;&#x3002;</p>
<p>Enum types with identically named constants coexist peacefully because each type has its own namespace. You can add or reorder constants in an enum type without recompiling its clients because the fields that export the constants provide a layer of insulation between an enum type and its clients: constant values are not compiled into the clients as they are in the int enum patterns. Finally, you can translate enums into printable strings by calling their toString method.</p>
<p>&#x540D;&#x79F0;&#x76F8;&#x540C;&#x7684;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x5E38;&#x91CF;&#x80FD;&#x548C;&#x5E73;&#x5171;&#x5B58;&#xFF0C;&#x56E0;&#x4E3A;&#x6BCF;&#x79CD;&#x7C7B;&#x578B;&#x90FD;&#x6709;&#x81EA;&#x5DF1;&#x7684;&#x540D;&#x79F0;&#x7A7A;&#x95F4;&#x3002;&#x4F60;&#x53EF;&#x4EE5;&#x5728;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x4E2D;&#x6DFB;&#x52A0;&#x6216;&#x91CD;&#x65B0;&#x6392;&#x5E8F;&#x5E38;&#x91CF;&#xFF0C;&#x800C;&#x65E0;&#x9700;&#x91CD;&#x65B0;&#x7F16;&#x8BD1;&#x5176;&#x5BA2;&#x6237;&#x7AEF;&#xFF0C;&#x56E0;&#x4E3A;&#x5BFC;&#x51FA;&#x5E38;&#x91CF;&#x7684;&#x5B57;&#x6BB5;&#x5728;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x53CA;&#x5176;&#x5BA2;&#x6237;&#x7AEF;&#x4E4B;&#x95F4;&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x5C42;&#x9694;&#x79BB;&#xFF1A;&#x5E38;&#x91CF;&#x503C;&#x4E0D;&#x4F1A;&#x50CF;&#x5728; int &#x679A;&#x4E3E;&#x6A21;&#x5F0F;&#x4E2D;&#x90A3;&#x6837;&#x7F16;&#x8BD1;&#x5230;&#x5BA2;&#x6237;&#x7AEF;&#x4E2D;&#x3002;&#x6700;&#x540E;&#xFF0C;&#x4F60;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x8C03;&#x7528;&#x679A;&#x4E3E;&#x7684; toString &#x65B9;&#x6CD5;&#x5C06;&#x5176;&#x8F6C;&#x6362;&#x4E3A;&#x53EF;&#x6253;&#x5370;&#x7684;&#x5B57;&#x7B26;&#x4E32;&#x3002;</p>
<p>In addition to rectifying the deficiencies of int enums, enum types let you add arbitrary methods and fields and implement arbitrary interfaces. They provide high-quality implementations of all the Object methods (Chapter 3), they implement Comparable (Item 14) and Serializable (Chapter 12), and their serialized form is designed to withstand most changes to the enum type.</p>
<p>&#x9664;&#x4E86;&#x7EA0;&#x6B63; int &#x679A;&#x4E3E;&#x7684;&#x4E0D;&#x8DB3;&#x4E4B;&#x5916;&#xFF0C;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x8FD8;&#x5141;&#x8BB8;&#x6DFB;&#x52A0;&#x4EFB;&#x610F;&#x65B9;&#x6CD5;&#x548C;&#x5B57;&#x6BB5;&#x5E76;&#x5B9E;&#x73B0;&#x4EFB;&#x610F;&#x63A5;&#x53E3;&#x3002;&#x5B83;&#x4EEC;&#x63D0;&#x4F9B;&#x4E86;&#x6240;&#x6709; Object &#x65B9;&#x6CD5;&#x7684;&#x9AD8;&#x8D28;&#x91CF;&#x5B9E;&#x73B0;&#xFF08;&#x53C2;&#x9605; Chapter 3&#xFF09;&#xFF0C;&#x8FD8;&#x5B9E;&#x73B0;&#x4E86; Comparable&#xFF08;<a href="../Chapter-3/Chapter-3-Item-14-Consider-implementing-Comparable.html">Item-14</a>&#xFF09;&#x548C; Serializable&#xFF08;&#x53C2;&#x9605; Chapter 12&#xFF09;&#xFF0C;&#x5E76;&#x4E14;&#x5B83;&#x4EEC;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x5F62;&#x5F0F;&#x88AB;&#x8BBE;&#x8BA1;&#x6210;&#x80FD;&#x591F;&#x9002;&#x5E94;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x7684;&#x53EF;&#x53D8;&#x6027;&#x3002;</p>
<p>So why would you want to add methods or fields to an enum type? For starters, you might want to associate data with its constants. Our Apple and Orange types, for example, might benefit from a method that returns the color of the fruit, or one that returns an image of it. You can augment an enum type with any method that seems appropriate. An enum type can start life as a simple collection of enum constants and evolve over time into a full-featured abstraction.</p>
<p>&#x90A3;&#x4E48;&#xFF0C;&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x5411;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x6DFB;&#x52A0;&#x65B9;&#x6CD5;&#x6216;&#x5B57;&#x6BB5;&#x5462;&#xFF1F;&#x9996;&#x5148;&#xFF0C;&#x4F60;&#x53EF;&#x80FD;&#x5E0C;&#x671B;&#x5C06;&#x6570;&#x636E;&#x4E0E;&#x5176;&#x5E38;&#x91CF;&#x5173;&#x8054;&#x8D77;&#x6765;&#x3002;&#x4F8B;&#x5982;&#xFF0C;&#x6211;&#x4EEC;&#x7684; Apple &#x548C; Orange &#x7C7B;&#x578B;&#x53EF;&#x80FD;&#x53D7;&#x76CA;&#x4E8E;&#x8FD4;&#x56DE;&#x6C34;&#x679C;&#x989C;&#x8272;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x6216;&#x8005;&#x8FD4;&#x56DE;&#x6C34;&#x679C;&#x56FE;&#x50CF;&#x7684;&#x65B9;&#x6CD5;&#x3002;&#x4F60;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x4EFB;&#x4F55;&#x9002;&#x5F53;&#x7684;&#x65B9;&#x6CD5;&#x6765;&#x6269;&#x5145;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x3002;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x53EF;&#x4EE5;&#x4ECE;&#x679A;&#x4E3E;&#x5E38;&#x91CF;&#x7684;&#x7B80;&#x5355;&#x96C6;&#x5408;&#x5F00;&#x59CB;&#xFF0C;&#x5E76;&#x968F;&#x7740;&#x65F6;&#x95F4;&#x7684;&#x63A8;&#x79FB;&#x6F14;&#x53D8;&#x4E3A;&#x529F;&#x80FD;&#x9F50;&#x5168;&#x7684;&#x62BD;&#x8C61;&#x3002;</p>
<p>For a nice example of a rich enum type, consider the eight planets of our solar system. Each planet has a mass and a radius, and from these two attributes you can compute its surface gravity. This in turn lets you compute the weight of an object on the planet&#x2019;s surface, given the mass of the object. Here&#x2019;s how this enum looks. The numbers in parentheses after each enum constant are parameters that are passed to its constructor. In this case, they are the planet&#x2019;s mass and radius:</p>
<p>&#x5BF9;&#x4E8E;&#x5BCC;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x6765;&#x8BF4;&#xFF0C;&#x6709;&#x4E2A;&#x5F88;&#x597D;&#x7684;&#x4F8B;&#x5B50;&#xFF0C;&#x8003;&#x8651;&#x6211;&#x4EEC;&#x592A;&#x9633;&#x7CFB;&#x7684;&#x516B;&#x9897;&#x884C;&#x661F;&#x3002;&#x6BCF;&#x9897;&#x884C;&#x661F;&#x90FD;&#x6709;&#x8D28;&#x91CF;&#x548C;&#x534A;&#x5F84;&#xFF0C;&#x901A;&#x8FC7;&#x8FD9;&#x4E24;&#x4E2A;&#x5C5E;&#x6027;&#x4F60;&#x53EF;&#x4EE5;&#x8BA1;&#x7B97;&#x51FA;&#x5B83;&#x7684;&#x8868;&#x9762;&#x5F15;&#x529B;&#x3002;&#x53CD;&#x8FC7;&#x6765;&#xFF0C;&#x53EF;&#x4EE5;&#x7ED9;&#x5B9A;&#x7269;&#x4F53;&#x7684;&#x8D28;&#x91CF;&#xFF0C;&#x8BA9;&#x4F60;&#x8BA1;&#x7B97;&#x51FA;&#x4E00;&#x4E2A;&#x7269;&#x4F53;&#x5728;&#x884C;&#x661F;&#x8868;&#x9762;&#x7684;&#x91CD;&#x91CF;&#x3002;&#x8FD9;&#x4E2A;&#x679A;&#x4E3E;&#x662F;&#x8FD9;&#x6837;&#x7684;&#x3002;&#x6BCF;&#x4E2A;&#x679A;&#x4E3E;&#x5E38;&#x91CF;&#x540E;&#x62EC;&#x53F7;&#x4E2D;&#x7684;&#x6570;&#x5B57;&#x662F;&#x4F20;&#x9012;&#x7ED9;&#x5176;&#x6784;&#x9020;&#x51FD;&#x6570;&#x7684;&#x53C2;&#x6570;&#x3002;&#x5728;&#x672C;&#x4F8B;&#x4E2D;&#xFF0C;&#x5B83;&#x4EEC;&#x662F;&#x884C;&#x661F;&#x7684;&#x8D28;&#x91CF;&#x548C;&#x534A;&#x5F84;&#xFF1A;</p>
<pre><code>// Enum type with data and behavior
public enum Planet {
    MERCURY(3.302e+23, 2.439e6),
    VENUS (4.869e+24, 6.052e6),
    EARTH (5.975e+24, 6.378e6),
    MARS (6.419e+23, 3.393e6),
    JUPITER(1.899e+27, 7.149e7),
    SATURN (5.685e+26, 6.027e7),
    URANUS (8.683e+25, 2.556e7),
    NEPTUNE(1.024e+26, 2.477e7);

    private final double mass; // In kilograms
    private final double radius; // In meters
    private final double surfaceGravity; // In m / s^2

    // Universal gravitational constant in m^3 / kg s^2
    private static final double G = 6.67300E-11;

    // Constructor
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
        surfaceGravity = G * mass / (radius * radius);
    }

    public double mass() { return mass; }
    public double radius() { return radius; }
    public double surfaceGravity() { return surfaceGravity; }

    public double surfaceWeight(double mass) {
        return mass * surfaceGravity; // F = ma
    }
}
</code></pre><p>It is easy to write a rich enum type such as Planet. <strong>To associate data with enum constants, declare instance fields and write a constructor that takes the data and stores it in the fields.</strong> Enums are by their nature immutable, so all fields should be final (Item 17). Fields can be public, but it is better to make them private and provide public accessors (Item 16). In the case of Planet, the constructor also computes and stores the surface gravity, but this is just an optimization. The gravity could be recomputed from the mass and radius each time it was used by the surfaceWeight method, which takes an object&#x2019;s mass and returns its weight on the planet represented by the constant. While the Planet enum is simple, it is surprisingly powerful. Here is a short program that takes the earth weight of an object (in any unit) and prints a nice table of the object&#x2019;s weight on all eight planets (in the same unit):</p>
<p>&#x7F16;&#x5199;&#x4E00;&#x4E2A;&#x5BCC;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x5F88;&#x5BB9;&#x6613;&#xFF0C;&#x5982;&#x4E0A;&#x8FF0;&#x7684; Planet&#x3002;<strong>&#x8981;&#x5C06;&#x6570;&#x636E;&#x4E0E;&#x679A;&#x4E3E;&#x5E38;&#x91CF;&#x5173;&#x8054;&#xFF0C;&#x53EF;&#x58F0;&#x660E;&#x5B9E;&#x4F8B;&#x5B57;&#x6BB5;&#x5E76;&#x7F16;&#x5199;&#x4E00;&#x4E2A;&#x6784;&#x9020;&#x51FD;&#x6570;&#xFF0C;&#x8BE5;&#x6784;&#x9020;&#x51FD;&#x6570;&#x63A5;&#x53D7;&#x6570;&#x636E;&#x5E76;&#x5C06;&#x5176;&#x5B58;&#x50A8;&#x5728;&#x5B57;&#x6BB5;&#x4E2D;&#x3002;</strong> &#x679A;&#x4E3E;&#x672C;&#x8D28;&#x4E0A;&#x662F;&#x4E0D;&#x53EF;&#x53D8;&#x7684;&#xFF0C;&#x56E0;&#x6B64;&#x6240;&#x6709;&#x5B57;&#x6BB5;&#x90FD;&#x5E94;&#x8BE5;&#x662F; final&#xFF08;<a href="../Chapter-4/Chapter-4-Item-17-Minimize-mutability.html">Item-17</a>&#xFF09;&#x3002;&#x5B57;&#x6BB5;&#x53EF;&#x4EE5;&#x662F;&#x516C;&#x5171;&#x7684;&#xFF0C;&#x4F46;&#x662F;&#x6700;&#x597D;&#x5C06;&#x5B83;&#x4EEC;&#x8BBE;&#x7F6E;&#x4E3A;&#x79C1;&#x6709;&#x5E76;&#x63D0;&#x4F9B;&#x516C;&#x5171;&#x8BBF;&#x95EE;&#x5668;&#xFF08;<a href="../Chapter-4/Chapter-4-Item-16-In-public-classes-use-accessor-methods-not-public-fields.html">Item-16</a>&#xFF09;&#x3002;&#x5728; Planet &#x7684;&#x4F8B;&#x5B50;&#x4E2D;&#xFF0C;&#x6784;&#x9020;&#x51FD;&#x6570;&#x8FD8;&#x8BA1;&#x7B97;&#x548C;&#x5B58;&#x50A8;&#x8868;&#x9762;&#x91CD;&#x529B;&#xFF0C;&#x4F46;&#x8FD9;&#x53EA;&#x662F;&#x4E00;&#x4E2A;&#x4F18;&#x5316;&#x3002;&#x6BCF;&#x4E00;&#x6B21;&#x4F7F;&#x7528; surfaceWeight &#x65B9;&#x6CD5;&#x65F6;&#xFF0C;&#x90FD;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x8D28;&#x91CF;&#x548C;&#x534A;&#x5F84;&#x91CD;&#x65B0;&#x8BA1;&#x7B97;&#x91CD;&#x529B;&#x3002;surfaceWeight &#x65B9;&#x6CD5;&#x83B7;&#x53D6;&#x4E00;&#x4E2A;&#x7269;&#x4F53;&#x7684;&#x8D28;&#x91CF;&#xFF0C;&#x5E76;&#x8FD4;&#x56DE;&#x5176;&#x5728;&#x8BE5;&#x5E38;&#x6570;&#x6240;&#x8868;&#x793A;&#x7684;&#x884C;&#x661F;&#x4E0A;&#x7684;&#x91CD;&#x91CF;&#x3002;&#x867D;&#x7136; Planet &#x679A;&#x4E3E;&#x5F88;&#x7B80;&#x5355;&#xFF0C;&#x4F46;&#x5B83;&#x7684;&#x529B;&#x91CF;&#x60CA;&#x4EBA;&#x3002;&#x4E0B;&#x9762;&#x662F;&#x4E00;&#x4E2A;&#x7B80;&#x77ED;&#x7684;&#x7A0B;&#x5E8F;&#xFF0C;&#x5B83;&#x83B7;&#x53D6;&#x4E00;&#x4E2A;&#x7269;&#x4F53;&#x7684;&#x5730;&#x7403;&#x91CD;&#x91CF;&#xFF08;&#x4EE5;&#x4EFB;&#x4F55;&#x5355;&#x4F4D;&#x8868;&#x793A;&#xFF09;&#xFF0C;&#x5E76;&#x6253;&#x5370;&#x4E00;&#x4E2A;&#x6F02;&#x4EAE;&#x7684;&#x8868;&#x683C;&#xFF0C;&#x663E;&#x793A;&#x8BE5;&#x7269;&#x4F53;&#x5728;&#x6240;&#x6709; 8 &#x4E2A;&#x884C;&#x661F;&#x4E0A;&#x7684;&#x91CD;&#x91CF;&#xFF08;&#x4EE5;&#x76F8;&#x540C;&#x7684;&#x5355;&#x4F4D;&#x8868;&#x793A;&#xFF09;&#xFF1A;</p>
<pre><code>public class WeightTable {
    public static void main(String[] args) {
        double earthWeight = Double.parseDouble(args[0]);
        double mass = earthWeight / Planet.EARTH.surfaceGravity();
    for (Planet p : Planet.values())
        System.out.printf(&quot;Weight on %s is %f%n&quot;,p, p.surfaceWeight(mass));
    }
}
</code></pre><p>Note that Planet, like all enums, has a static values method that returns an array of its values in the order they were declared. Note also that the toString method returns the declared name of each enum value, enabling easy printing by println and printf. If you&#x2019;re dissatisfied with this string representation, you can change it by overriding the toString method. Here is the result of running our WeightTable program (which doesn&#x2019;t override toString) with the command line argument 185:</p>
<p>&#x8BF7;&#x6CE8;&#x610F;&#xFF0C;Planet &#x548C;&#x6240;&#x6709;&#x679A;&#x4E3E;&#x4E00;&#x6837;&#xFF0C;&#x6709;&#x4E00;&#x4E2A;&#x9759;&#x6001; values() &#x65B9;&#x6CD5;&#xFF0C;&#x8BE5;&#x65B9;&#x6CD5;&#x6309;&#x7167;&#x58F0;&#x660E;&#x503C;&#x7684;&#x987A;&#x5E8F;&#x8FD4;&#x56DE;&#x5176;&#x503C;&#x7684;&#x6570;&#x7EC4;&#x3002;&#x8FD8;&#x8981;&#x6CE8;&#x610F;&#x7684;&#x662F;&#xFF0C;toString &#x65B9;&#x6CD5;&#x8FD4;&#x56DE;&#x6BCF;&#x4E2A;&#x679A;&#x4E3E;&#x503C;&#x7684;&#x58F0;&#x660E;&#x540D;&#x79F0;&#xFF0C;&#x8FD9;&#x6837;&#x5C31;&#x53EF;&#x4EE5;&#x901A;&#x8FC7; println &#x548C; printf &#x8F7B;&#x677E;&#x6253;&#x5370;&#x3002;&#x5982;&#x679C;&#x4F60;&#x5BF9;&#x8FD9;&#x4E2A;&#x5B57;&#x7B26;&#x4E32;&#x8868;&#x793A;&#x4E0D;&#x6EE1;&#x610F;&#xFF0C;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x91CD;&#x5199; toString &#x65B9;&#x6CD5;&#x6765;&#x66F4;&#x6539;&#x5B83;&#x3002;&#x4E0B;&#x9762;&#x662F;&#x7528;&#x547D;&#x4EE4;&#x884C;&#x8FD0;&#x884C;&#x6211;&#x4EEC;&#x7684; WeightTable &#x7A0B;&#x5E8F;&#xFF08;&#x672A;&#x8986;&#x76D6; toString&#xFF09;&#x7684;&#x7ED3;&#x679C;&#xFF1A;</p>
<pre><code>Weight on MERCURY is 69.912739
Weight on VENUS is 167.434436
Weight on EARTH is 185.000000
Weight on MARS is 70.226739
Weight on JUPITER is 467.990696
Weight on SATURN is 197.120111
Weight on URANUS is 167.398264
Weight on NEPTUNE is 210.208751
</code></pre><p>Until 2006, two years after enums were added to Java, Pluto was a planet. This raises the question &#x201C;what happens when you remove an element from an enum type?&#x201D; The answer is that any client program that doesn&#x2019;t refer to the removed element will continue to work fine. So, for example, our WeightTable program would simply print a table with one fewer row. And what of a client program that refers to the removed element (in this case, Planet.Pluto)? If you recompile the client program, the compilation will fail with a helpful error message at the line that refers to the erstwhile planet; if you fail to recompile the client, it will throw a helpful exception from this line at runtime. This is the best behavior you could hope for, far better than what you&#x2019;d get with the int enum pattern.</p>
<p>&#x76F4;&#x5230; 2006 &#x5E74;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x679A;&#x4E3E;&#x88AB;&#x6DFB;&#x52A0;&#x5230; Java &#x7684;&#x4E24;&#x5E74;&#x540E;&#xFF0C;&#x51A5;&#x738B;&#x661F;&#x8FD8;&#x662F;&#x4E00;&#x9897;&#x884C;&#x661F;&#x3002;&#x8FD9;&#x5C31;&#x63D0;&#x51FA;&#x4E86;&#x4E00;&#x4E2A;&#x95EE;&#x9898;&#xFF1A;&#x300C;&#x4ECE;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x4E2D;&#x5220;&#x9664;&#x5143;&#x7D20;&#x65F6;&#x4F1A;&#x53D1;&#x751F;&#x4EC0;&#x4E48;?&#x300D;&#x7B54;&#x6848;&#x662F;&#xFF0C;&#x4EFB;&#x4F55;&#x4E0D;&#x5F15;&#x7528;&#x88AB;&#x5220;&#x9664;&#x5143;&#x7D20;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x7A0B;&#x5E8F;&#x5C06;&#x7EE7;&#x7EED;&#x6B63;&#x5E38;&#x5DE5;&#x4F5C;&#x3002;&#x4F8B;&#x5982;&#xFF0C;&#x6211;&#x4EEC;&#x7684; WeightTable &#x7A0B;&#x5E8F;&#x53EA;&#x9700;&#x6253;&#x5370;&#x4E00;&#x4E2A;&#x5C11;&#x4E00;&#x884C;&#x7684;&#x8868;&#x3002;&#x90A3;&#x4E48;&#x5F15;&#x7528;&#x88AB;&#x5220;&#x9664;&#x5143;&#x7D20;&#xFF08;&#x5728;&#x672C;&#x4F8B;&#x4E2D;&#x662F; Planet.Pluto&#xFF09;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x7A0B;&#x5E8F;&#x53C8;&#x5982;&#x4F55;&#x5462;&#xFF1F;&#x5982;&#x679C;&#x91CD;&#x65B0;&#x7F16;&#x8BD1;&#x5BA2;&#x6237;&#x7AEF;&#x7A0B;&#x5E8F;&#xFF0C;&#x7F16;&#x8BD1;&#x5C06;&#x5931;&#x8D25;&#xFF0C;&#x5E76;&#x5728;&#x5F15;&#x7528;&#x8BE5;&#x300C;&#x8FC7;&#x65F6;&#x300D;&#x884C;&#x661F;&#x7684;&#x884C;&#x4E2D;&#x663E;&#x793A;&#x4E00;&#x6761;&#x6709;&#x7528;&#x7684;&#x9519;&#x8BEF;&#x6D88;&#x606F;&#xFF1B;&#x5982;&#x679C;&#x4F60;&#x672A;&#x80FD;&#x91CD;&#x65B0;&#x7F16;&#x8BD1;&#x5BA2;&#x6237;&#x7AEF;&#xFF0C;&#x5B83;&#x5C06;&#x5728;&#x8FD0;&#x884C;&#x65F6;&#x4ECE;&#x8FD9;&#x884C;&#x629B;&#x51FA;&#x4E00;&#x4E2A;&#x6709;&#x7528;&#x7684;&#x5F02;&#x5E38;&#x3002;&#x8FD9;&#x662F;&#x4F60;&#x6240;&#x5E0C;&#x671B;&#x7684;&#x6700;&#x4F73;&#x884C;&#x4E3A;&#xFF0C;&#x6BD4; int &#x679A;&#x4E3E;&#x6A21;&#x5F0F;&#x8981;&#x597D;&#x5F97;&#x591A;&#x3002;</p>
<p>Some behaviors associated with enum constants may need to be used only from within the class or package in which the enum is defined. Such behaviors are best implemented as private or package-private methods. Each constant then carries with it a hidden collection of behaviors that allows the class or package containing the enum to react appropriately when presented with the constant. Just as with other classes, unless you have a compelling reason to expose an enum method to its clients, declare it private or, if need be, package-private (Item 15).</p>
<p>&#x4E0E;&#x679A;&#x4E3E;&#x5E38;&#x91CF;&#x76F8;&#x5173;&#x7684;&#x4E00;&#x4E9B;&#x884C;&#x4E3A;&#x53EF;&#x80FD;&#x53EA;&#x9700;&#x8981;&#x5728;&#x5B9A;&#x4E49;&#x679A;&#x4E3E;&#x7684;&#x7C7B;&#x6216;&#x5305;&#x4E2D;&#x4F7F;&#x7528;&#x3002;&#x6B64;&#x7C7B;&#x884C;&#x4E3A;&#x6700;&#x597D;&#x4EE5;&#x79C1;&#x6709;&#x6216;&#x5305;&#x79C1;&#x6709;&#x65B9;&#x6CD5;&#x6765;&#x5B9E;&#x73B0;&#x3002;&#x7136;&#x540E;&#xFF0C;&#x6BCF;&#x4E2A;&#x5E38;&#x91CF;&#x90FD;&#x5E26;&#x6709;&#x4E00;&#x4E2A;&#x9690;&#x85CF;&#x7684;&#x884C;&#x4E3A;&#x96C6;&#x5408;&#xFF0C;&#x5141;&#x8BB8;&#x5305;&#x542B;&#x679A;&#x4E3E;&#x7684;&#x7C7B;&#x6216;&#x5305;&#x5728;&#x4F7F;&#x7528;&#x8BE5;&#x5E38;&#x91CF;&#x65F6;&#x505A;&#x51FA;&#x9002;&#x5F53;&#x7684;&#x53CD;&#x5E94;&#x3002;&#x4E0E;&#x5176;&#x4ED6;&#x7C7B;&#x4E00;&#x6837;&#xFF0C;&#x9664;&#x975E;&#x4F60;&#x6709;&#x5145;&#x5206;&#x7684;&#x7406;&#x7531;&#x5411;&#x5176;&#x5BA2;&#x6237;&#x7AEF;&#x516C;&#x5F00;&#x679A;&#x4E3E;&#x65B9;&#x6CD5;&#xFF0C;&#x5426;&#x5219;&#x5C06;&#x5176;&#x58F0;&#x660E;&#x4E3A;&#x79C1;&#x6709;&#x7684;&#xFF0C;&#x6216;&#x8005;&#x5728;&#x5FC5;&#x8981;&#x65F6;&#x58F0;&#x660E;&#x4E3A;&#x5305;&#x79C1;&#x6709;&#xFF08;<a href="../Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.html">Item-15</a>&#xFF09;&#x3002;</p>
<p>If an enum is generally useful, it should be a top-level class; if its use is tied to a specific top-level class, it should be a member class of that top-level class (Item 24). For example, the java.math.RoundingMode enum represents a rounding mode for decimal fractions. These rounding modes are used by the BigDecimal class, but they provide a useful abstraction that is not fundamentally tied to BigDecimal. By making RoundingMode a top-level enum, the library designers encourage any programmer who needs rounding modes to reuse this enum, leading to increased consistency across APIs.</p>
<p>&#x901A;&#x5E38;&#xFF0C;&#x5982;&#x679C;&#x4E00;&#x4E2A;&#x679A;&#x4E3E;&#x7528;&#x9014;&#x5E7F;&#x6CDB;&#xFF0C;&#x90A3;&#x4E48;&#x5B83;&#x5E94;&#x8BE5;&#x662F;&#x9876;&#x7EA7;&#x7C7B;&#xFF1B;&#x5982;&#x679C;&#x5B83;&#x88AB;&#x7ED1;&#x5B9A;&#x5230;&#x4E00;&#x4E2A;&#x7279;&#x5B9A;&#x7684;&#x9876;&#x7EA7;&#x7C7B;&#x4F7F;&#x7528;&#xFF0C;&#x90A3;&#x4E48;&#x5B83;&#x5E94;&#x8BE5;&#x662F;&#x8FD9;&#x4E2A;&#x9876;&#x7EA7;&#x7C7B;&#xFF08;<a href="../Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.html">Item-24</a>&#xFF09;&#x7684;&#x6210;&#x5458;&#x7C7B;&#x3002;&#x4F8B;&#x5982;&#xFF0C;java.math.RoundingMode &#x679A;&#x4E3E;&#x8868;&#x793A;&#x5C0F;&#x6570;&#x90E8;&#x5206;&#x7684;&#x820D;&#x5165;&#x6A21;&#x5F0F;&#x3002;BigDecimal &#x7C7B;&#x4F7F;&#x7528;&#x8FD9;&#x4E9B;&#x56DB;&#x820D;&#x4E94;&#x5165;&#x6A21;&#x5F0F;&#xFF0C;&#x4F46;&#x662F;&#x5B83;&#x4EEC;&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x4E2A;&#x6709;&#x7528;&#x7684;&#x62BD;&#x8C61;&#xFF0C;&#x8FD9;&#x4E2A;&#x62BD;&#x8C61;&#x4E0E; BigDecimal &#x6CA1;&#x6709;&#x672C;&#x8D28;&#x4E0A;&#x7684;&#x8054;&#x7CFB;&#x3002;&#x901A;&#x8FC7;&#x4F7F; RoundingMode &#x6210;&#x4E3A;&#x9876;&#x7EA7;&#x679A;&#x4E3E;&#xFF0C;&#x5E93;&#x8BBE;&#x8BA1;&#x4EBA;&#x5458;&#x652F;&#x6301;&#x4EFB;&#x4F55;&#x9700;&#x8981;&#x820D;&#x5165;&#x6A21;&#x5F0F;&#x7684;&#x7A0B;&#x5E8F;&#x5458;&#x590D;&#x7528;&#x8BE5;&#x679A;&#x4E3E;&#xFF0C;&#x4ECE;&#x800C;&#x63D0;&#x9AD8; API &#x4E4B;&#x95F4;&#x7684;&#x4E00;&#x81F4;&#x6027;&#x3002;</p>
<p>The techniques demonstrated in the Planet example are sufficient for most enum types, but sometimes you need more. There is different data associated with each Planet constant, but sometimes you need to associate fundamentally different behavior with each constant. For example, suppose you are writing an enum type to represent the operations on a basic four-function calculator and you want to provide a method to perform the arithmetic operation represented by each constant. One way to achieve this is to switch on the value of the enum:</p>
<p>Planet &#x793A;&#x4F8B;&#x4E2D;&#x6F14;&#x793A;&#x7684;&#x6280;&#x672F;&#x5BF9;&#x4E8E;&#x5927;&#x591A;&#x6570;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x6765;&#x8BF4;&#x5DF2;&#x7ECF;&#x8DB3;&#x591F;&#x4E86;&#xFF0C;&#x4F46;&#x6709;&#x65F6;&#x8FD8;&#x9700;&#x8981;&#x66F4;&#x591A;&#x3002;&#x6BCF;&#x4E2A;&#x884C;&#x661F;&#x5E38;&#x6570;&#x90FD;&#x6709;&#x4E0D;&#x540C;&#x7684;&#x6570;&#x636E;&#xFF0C;&#x4F46;&#x6709;&#x65F6;&#x4F60;&#x9700;&#x8981;&#x5C06;&#x57FA;&#x672C;&#x4E0D;&#x540C;&#x7684;&#x884C;&#x4E3A;&#x4E0E;&#x6BCF;&#x4E2A;&#x5E38;&#x6570;&#x8054;&#x7CFB;&#x8D77;&#x6765;&#x3002;&#x4F8B;&#x5982;&#xFF0C;&#x5047;&#x8BBE;&#x4F60;&#x6B63;&#x5728;&#x7F16;&#x5199;&#x4E00;&#x4E2A;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x6765;&#x8868;&#x793A;&#x4E00;&#x4E2A;&#x57FA;&#x672C;&#x7684;&#x56DB;&#x5219;&#x8FD0;&#x7B97;&#x8BA1;&#x7B97;&#x5668;&#x4E0A;&#x7684;&#x64CD;&#x4F5C;&#xFF0C;&#x5E76;&#x4E14;&#x4F60;&#x5E0C;&#x671B;&#x63D0;&#x4F9B;&#x4E00;&#x4E2A;&#x65B9;&#x6CD5;&#x6765;&#x6267;&#x884C;&#x7531;&#x6BCF;&#x4E2A;&#x5E38;&#x91CF;&#x8868;&#x793A;&#x7684;&#x7B97;&#x672F;&#x64CD;&#x4F5C;&#x3002;&#x5B9E;&#x73B0;&#x8FD9;&#x4E00;&#x70B9;&#x7684;&#x4E00;&#x79CD;&#x65B9;&#x5F0F;&#x662F;&#x7528; switch &#x63A5;&#x6536;&#x679A;&#x4E3E;&#x503C;&#xFF1A;</p>
<pre><code>// Enum type that switches on its own value - questionable
public enum Operation {
    PLUS, MINUS, TIMES, DIVIDE;
    // Do the arithmetic operation represented by this constant
    public double apply(double x, double y) {
        switch(this) {
            case PLUS: return x + y;
            case MINUS: return x - y;
            case TIMES: return x * y;
            case DIVIDE: return x / y;
        }
    throw new AssertionError(&quot;Unknown op: &quot;+ this);
    }
}
</code></pre><p>This code works, but it isn&#x2019;t very pretty. It won&#x2019;t compile without the throw statement because the end of the method is technically reachable, even though it will never be reached [JLS, 14.21]. Worse, the code is fragile. If you add a new enum constant but forget to add a corresponding case to the switch, the enum will still compile, but it will fail at runtime when you try to apply the new operation.</p>
<p>&#x8FD9;&#x6BB5;&#x4EE3;&#x7801;&#x53EF;&#x4EE5;&#x5DE5;&#x4F5C;&#xFF0C;&#x4F46;&#x4E0D;&#x662F;&#x5F88;&#x6F02;&#x4EAE;&#x3002;&#x5982;&#x679C;&#x6CA1;&#x6709; throw &#x8BED;&#x53E5;&#xFF0C;&#x5B83;&#x5C06;&#x65E0;&#x6CD5;&#x7F16;&#x8BD1;&#xFF0C;&#x56E0;&#x4E3A;&#x4ECE;&#x7406;&#x8BBA;&#x4E0A;&#x8BB2;&#xFF0C;&#x65B9;&#x6CD5;&#x7684;&#x7ED3;&#x5C3E;&#x662F;&#x53EF;&#x5230;&#x8FBE;&#x7684;&#xFF0C;&#x5C3D;&#x7BA1;&#x5B83;&#x786E;&#x5B9E;&#x6C38;&#x8FDC;&#x4E0D;&#x4F1A;&#x5230;&#x8FBE; [JLS, 14.21]&#x3002;&#x66F4;&#x7CDF;&#x7CD5;&#x7684;&#x662F;&#xFF0C;&#x4EE3;&#x7801;&#x5F88;&#x8106;&#x5F31;&#x3002;&#x5982;&#x679C;&#x4F60;&#x6DFB;&#x52A0;&#x4E86;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x679A;&#x4E3E;&#x5E38;&#x91CF;&#xFF0C;&#x4F46;&#x5FD8;&#x8BB0;&#x5411; switch &#x6DFB;&#x52A0;&#x76F8;&#x5E94;&#x7684; case&#xFF0C;&#x5219;&#x679A;&#x4E3E;&#x4ECD;&#x5C06;&#x7F16;&#x8BD1;&#xFF0C;&#x4F46;&#x5728;&#x8FD0;&#x884C;&#x65F6;&#x5C1D;&#x8BD5;&#x5E94;&#x7528;&#x65B0;&#x64CD;&#x4F5C;&#x65F6;&#x5C06;&#x5931;&#x8D25;&#x3002;</p>
<p>Luckily, there is a better way to associate a different behavior with each enum constant: declare an abstract apply method in the enum type, and override it with a concrete method for each constant in a constant-specific class body. Such methods are known as constant-specific method implementations:</p>
<p>&#x5E78;&#x8FD0;&#x7684;&#x662F;&#xFF0C;&#x6709;&#x4E00;&#x79CD;&#x66F4;&#x597D;&#x7684;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x5C06;&#x4E0D;&#x540C;&#x7684;&#x884C;&#x4E3A;&#x4E0E;&#x6BCF;&#x4E2A;&#x679A;&#x4E3E;&#x5E38;&#x91CF;&#x5173;&#x8054;&#x8D77;&#x6765;&#xFF1A;&#x5728;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x4E2D;&#x58F0;&#x660E;&#x4E00;&#x4E2A;&#x62BD;&#x8C61;&#x7684; apply &#x65B9;&#x6CD5;&#xFF0C;&#x5E76;&#x7528;&#x4E00;&#x4E2A;&#x7279;&#x5B9A;&#x4E8E;&#x5E38;&#x91CF;&#x7684;&#x7C7B;&#x4F53;&#x4E2D;&#x7684;&#x6BCF;&#x4E2A;&#x5E38;&#x91CF;&#x7684;&#x5177;&#x4F53;&#x65B9;&#x6CD5;&#x8986;&#x76D6;&#x5B83;&#x3002;&#x8FD9;&#x4E9B;&#x65B9;&#x6CD5;&#x79F0;&#x4E3A;&#x7279;&#x5B9A;&#x5E38;&#x91CF;&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;&#xFF1A;</p>
<pre><code>// Enum type with constant-specific method implementations
public enum Operation {
    PLUS {public double apply(double x, double y){return x + y;}},
    MINUS {public double apply(double x, double y){return x - y;}},
    TIMES {public double apply(double x, double y){return x * y;}},
    DIVIDE{public double apply(double x, double y){return x / y;}};
    public abstract double apply(double x, double y);
}
</code></pre><p>If you add a new constant to the second version of Operation, it is unlikely that you&#x2019;ll forget to provide an apply method, because the method immediately follows each constant declaration. In the unlikely event that you do forget, the compiler will remind you because abstract methods in an enum type must be overridden with concrete methods in all of its constants.</p>
<p>&#x5982;&#x679C;&#x4F60;&#x5728; Operation &#x679A;&#x4E3E;&#x7684;&#x7B2C;&#x4E8C;&#x4E2A;&#x7248;&#x672C;&#x4E2D;&#x6DFB;&#x52A0;&#x4E00;&#x4E2A;&#x65B0;&#x5E38;&#x91CF;&#xFF0C;&#x90A3;&#x4E48;&#x4F60;&#x4E0D;&#x592A;&#x53EF;&#x80FD;&#x5FD8;&#x8BB0;&#x63D0;&#x4F9B;&#x4E00;&#x4E2A; apply &#x65B9;&#x6CD5;&#xFF0C;&#x56E0;&#x4E3A;&#x8BE5;&#x65B9;&#x6CD5;&#x7D27;&#x8DDF;&#x6BCF;&#x4E2A;&#x5E38;&#x91CF;&#x58F0;&#x660E;&#x3002;&#x5728;&#x4E0D;&#x592A;&#x53EF;&#x80FD;&#x5FD8;&#x8BB0;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x7F16;&#x8BD1;&#x5668;&#x4F1A;&#x63D0;&#x9192;&#x4F60;&#xFF0C;&#x56E0;&#x4E3A;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x4E2D;&#x7684;&#x62BD;&#x8C61;&#x65B9;&#x6CD5;&#x5FC5;&#x987B;&#x7528;&#x5176;&#x6240;&#x6709;&#x5E38;&#x91CF;&#x4E2D;&#x7684;&#x5177;&#x4F53;&#x65B9;&#x6CD5;&#x8986;&#x76D6;&#x3002;</p>
<p>Constant-specific method implementations can be combined with constantspecific data. For example, here is a version of Operation that overrides the toString method to return the symbol commonly associated with the operation:</p>
<p>&#x7279;&#x5B9A;&#x5E38;&#x91CF;&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;&#x53EF;&#x4EE5;&#x4E0E;&#x7279;&#x5B9A;&#x4E8E;&#x5E38;&#x91CF;&#x7684;&#x6570;&#x636E;&#x76F8;&#x7ED3;&#x5408;&#x3002;&#x4F8B;&#x5982;&#xFF0C;&#x4E0B;&#x9762;&#x662F; Operation &#x679A;&#x4E3E;&#x7684;&#x4E00;&#x4E2A;&#x7248;&#x672C;&#xFF0C;&#x5B83;&#x91CD;&#x5199; toString &#x65B9;&#x6CD5;&#x6765;&#x8FD4;&#x56DE;&#x4E0E;&#x64CD;&#x4F5C;&#x76F8;&#x5173;&#x7684;&#x7B26;&#x53F7;&#xFF1A;</p>
<p><strong>&#x8BD1;&#x6CE8;&#xFF1A;&#x539F;&#x6587; constantspecific data &#x5E94;&#x4FEE;&#x6539;&#x4E3A; constant-specific data &#xFF0C;&#x8BD1;&#x4E3A;&#x300C;&#x7279;&#x5B9A;&#x5E38;&#x91CF;&#x6570;&#x636E;&#x300D;</strong></p>
<pre><code>// Enum type with constant-specific class bodies and data
public enum Operation {
    PLUS(&quot;+&quot;) {
        public double apply(double x, double y) { return x + y; }
    },
    MINUS(&quot;-&quot;) {
        public double apply(double x, double y) { return x - y; }
    },
    TIMES(&quot;*&quot;) {
        public double apply(double x, double y) { return x * y; }
    },
    DIVIDE(&quot;/&quot;) {
        public double apply(double x, double y) { return x / y; }
    };

    private final String symbol;

    Operation(String symbol) { this.symbol = symbol; }

    @Override
    public String toString() { return symbol; }

    public abstract double apply(double x, double y);
}
</code></pre><p>The toString implementation shown makes it easy to print arithmetic expressions, as demonstrated by this little program:</p>
<p>&#x91CD;&#x5199;&#x7684; toString &#x5B9E;&#x73B0;&#x4F7F;&#x5F97;&#x6253;&#x5370;&#x7B97;&#x672F;&#x8868;&#x8FBE;&#x5F0F;&#x53D8;&#x5F97;&#x5F88;&#x5BB9;&#x6613;&#xFF0C;&#x5982;&#x4E0B;&#x9762;&#x7684;&#x5C0F;&#x7A0B;&#x5E8F;&#x6240;&#x793A;&#xFF1A;</p>
<pre><code>public static void main(String[] args) {
    double x = Double.parseDouble(args[0]);
    double y = Double.parseDouble(args[1]);
    for (Operation op : Operation.values())
        System.out.printf(&quot;%f %s %f = %f%n&quot;,x, op, y, op.apply(x, y));
}
</code></pre><p>Running this program with 2 and 4 as command line arguments produces the following output:</p>
<p>&#x4EE5; 2 &#x548C; 4 &#x4F5C;&#x4E3A;&#x547D;&#x4EE4;&#x884C;&#x53C2;&#x6570;&#x8FD0;&#x884C;&#x8FD9;&#x4E2A;&#x7A0B;&#x5E8F;&#x5C06;&#x4EA7;&#x751F;&#x4EE5;&#x4E0B;&#x8F93;&#x51FA;&#xFF1A;</p>
<pre><code>2.000000 + 4.000000 = 6.000000
2.000000 - 4.000000 = -2.000000
2.000000 * 4.000000 = 8.000000
2.000000 / 4.000000 = 0.500000
</code></pre><p>Enum types have an automatically generated valueOf(String) method that translates a constant&#x2019;s name into the constant itself. If you override the toString method in an enum type, consider writing a fromString method to translate the custom string representation back to the corresponding enum. The following code (with the type name changed appropriately) will do the trick for any enum, so long as each constant has a unique string representation:</p>
<p>&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x6709;&#x4E00;&#x4E2A;&#x81EA;&#x52A8;&#x751F;&#x6210;&#x7684; valueOf(String) &#x65B9;&#x6CD5;&#xFF0C;&#x8BE5;&#x65B9;&#x6CD5;&#x5C06;&#x5E38;&#x91CF;&#x7684;&#x540D;&#x79F0;&#x8F6C;&#x6362;&#x4E3A;&#x5E38;&#x91CF;&#x672C;&#x8EAB;&#x3002;&#x5982;&#x679C;&#x5728;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x4E2D;&#x91CD;&#x5199; toString &#x65B9;&#x6CD5;&#xFF0C;&#x53EF;&#x4EE5;&#x8003;&#x8651;&#x7F16;&#x5199; fromString &#x65B9;&#x6CD5;&#x5C06;&#x81EA;&#x5B9A;&#x4E49;&#x5B57;&#x7B26;&#x4E32;&#x8868;&#x793A;&#x5F62;&#x5F0F;&#x8F6C;&#x6362;&#x56DE;&#x76F8;&#x5E94;&#x7684;&#x679A;&#x4E3E;&#x3002;&#x53EA;&#x8981;&#x6BCF;&#x4E2A;&#x5E38;&#x91CF;&#x90FD;&#x6709;&#x552F;&#x4E00;&#x7684;&#x5B57;&#x7B26;&#x4E32;&#x8868;&#x793A;&#x5F62;&#x5F0F;&#xFF0C;&#x4E0B;&#x9762;&#x7684;&#x4EE3;&#x7801;&#xFF08;&#x7C7B;&#x578B;&#x540D;&#x79F0;&#x9002;&#x5F53;&#x66F4;&#x6539;&#xFF09;&#x5C31;&#x53EF;&#x4EE5;&#x7528;&#x4E8E;&#x4EFB;&#x4F55;&#x679A;&#x4E3E;&#xFF1A;</p>
<pre><code>// Implementing a fromString method on an enum type
private static final Map&lt;String, Operation&gt; stringToEnum =Stream.of(values()).collect(toMap(Object::toString, e -&gt; e));

// Returns Operation for string, if any
public static Optional&lt;Operation&gt; fromString(String symbol) {
    return Optional.ofNullable(stringToEnum.get(symbol));
}
</code></pre><p>Note that the Operation constants are put into the stringToEnum map from a static field initialization that runs after the enum constants have been created. The previous code uses a stream (Chapter 7) over the array returned by the values() method; prior to Java 8, we would have created an empty hash map and iterated over the values array inserting the string-to-enum mappings into the map, and you can still do it that way if you prefer. But note that attempting to have each constant put itself into a map from its own constructor does not work. It would cause a compilation error, which is good thing because if it were legal, it would cause a NullPointerException at runtime. Enum constructors aren&#x2019;t permitted to access the enum&#x2019;s static fields, with the exception of constant variables (Item 34). This restriction is necessary because static fields have not yet been initialized when enum constructors run. A special case of this restriction is that enum constants cannot access one another from their constructors.</p>
<p>&#x6CE8;&#x610F;&#xFF0C;Operation &#x679A;&#x4E3E;&#x7684;&#x5E38;&#x91CF;&#x662F;&#x4ECE;&#x521B;&#x5EFA;&#x679A;&#x4E3E;&#x5E38;&#x91CF;&#x4E4B;&#x540E;&#x8FD0;&#x884C;&#x7684;&#x9759;&#x6001;&#x5B57;&#x6BB5;&#x521D;&#x59CB;&#x5316;&#x4E2D;&#x653E;&#x5165; stringToEnum &#x7684;&#x3002;&#x4E0A;&#x8FF0;&#x4EE3;&#x7801;&#x5728; values() &#x65B9;&#x6CD5;&#x8FD4;&#x56DE;&#x7684;&#x6570;&#x7EC4;&#x4E0A;&#x4F7F;&#x7528;&#x6D41;&#xFF08;&#x53C2;&#x9605;&#x7B2C; 7 &#x7AE0;&#xFF09;&#xFF1B;&#x5728; Java 8 &#x4E4B;&#x524D;&#xFF0C;&#x6211;&#x4EEC;&#x5C06;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x7A7A; HashMap&#xFF0C;&#x5E76;&#x904D;&#x5386;&#x503C;&#x6570;&#x7EC4;&#xFF0C;&#x5C06;&#x81EA;&#x5B9A;&#x4E49;&#x5B57;&#x7B26;&#x4E32;&#x4E0E;&#x679A;&#x4E3E;&#x7684;&#x6620;&#x5C04;&#x63D2;&#x5165;&#x5230; HashMap &#x4E2D;&#xFF0C;&#x5982;&#x679C;&#x4F60;&#x613F;&#x610F;&#xFF0C;&#x4F60;&#x4ECD;&#x7136;&#x53EF;&#x4EE5;&#x8FD9;&#x6837;&#x505A;&#x3002;&#x4F46;&#x662F;&#x8BF7;&#x6CE8;&#x610F;&#xFF0C;&#x8BD5;&#x56FE;&#x8BA9;&#x6BCF;&#x4E2A;&#x5E38;&#x91CF;&#x901A;&#x8FC7;&#x6784;&#x9020;&#x51FD;&#x6570;&#x5C06;&#x81EA;&#x8EAB;&#x653E;&#x5165; HashMap &#x4E2D;&#x662F;&#x884C;&#x4E0D;&#x901A;&#x7684;&#x3002;&#x5B83;&#x4F1A;&#x5BFC;&#x81F4;&#x7F16;&#x8BD1;&#x9519;&#x8BEF;&#xFF0C;&#x8FD9;&#x662F;&#x597D;&#x4E8B;&#xFF0C;&#x56E0;&#x4E3A;&#x5982;&#x679C;&#x5408;&#x6CD5;&#xFF0C;&#x5B83;&#x4F1A;&#x5728;&#x8FD0;&#x884C;&#x65F6;&#x5BFC;&#x81F4; NullPointerException&#x3002;&#x679A;&#x4E3E;&#x6784;&#x9020;&#x51FD;&#x6570;&#x4E0D;&#x5141;&#x8BB8;&#x8BBF;&#x95EE;&#x679A;&#x4E3E;&#x7684;&#x9759;&#x6001;&#x5B57;&#x6BB5;&#xFF0C;&#x5E38;&#x91CF;&#x53D8;&#x91CF;&#x9664;&#x5916;&#xFF08;<a href="Chapter-6-Item-34-Use-enums-instead-of-int-constants.html">Item-34</a>&#xFF09;&#x3002;&#x8FD9;&#x4E2A;&#x9650;&#x5236;&#x662F;&#x5FC5;&#x8981;&#x7684;&#xFF0C;&#x56E0;&#x4E3A;&#x5728;&#x679A;&#x4E3E;&#x6784;&#x9020;&#x51FD;&#x6570;&#x8FD0;&#x884C;&#x65F6;&#x9759;&#x6001;&#x5B57;&#x6BB5;&#x8FD8;&#x6CA1;&#x6709;&#x521D;&#x59CB;&#x5316;&#x3002;&#x8FD9;&#x79CD;&#x9650;&#x5236;&#x7684;&#x4E00;&#x4E2A;&#x7279;&#x6B8A;&#x60C5;&#x51B5;&#x662F;&#x679A;&#x4E3E;&#x5E38;&#x91CF;&#x4E0D;&#x80FD;&#x4ECE;&#x5B83;&#x4EEC;&#x7684;&#x6784;&#x9020;&#x51FD;&#x6570;&#x4E2D;&#x76F8;&#x4E92;&#x8BBF;&#x95EE;&#x3002;</p>
<p>Also note that the fromString method returns an <code>Optional&lt;String&gt;</code>. This allows the method to indicate that the string that was passed in does not represent a valid operation, and it forces the client to confront this possibility (Item 55).</p>
<p>&#x8FD8;&#x8981;&#x6CE8;&#x610F; fromString &#x65B9;&#x6CD5;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A; <code>Optional&lt;String&gt;</code>&#x3002;&#x8FD9;&#x5141;&#x8BB8;&#x8BE5;&#x65B9;&#x6CD5;&#x63D0;&#x793A;&#x4F20;&#x5165;&#x7684;&#x5B57;&#x7B26;&#x4E32;&#x5E76;&#x975E;&#x6709;&#x6548;&#x64CD;&#x4F5C;&#xFF0C;&#x5E76;&#x5F3A;&#x5236;&#x5BA2;&#x6237;&#x7AEF;&#x5904;&#x7406;&#x8FD9;&#x79CD;&#x53EF;&#x80FD;&#xFF08;<a href="../Chapter-8/Chapter-8-Item-55-Return-optionals-judiciously.html">Item-55</a>&#xFF09;&#x3002;</p>
<p>A disadvantage of constant-specific method implementations is that they make it harder to share code among enum constants. For example, consider an enum representing the days of the week in a payroll package. This enum has a method that calculates a worker&#x2019;s pay for that day given the worker&#x2019;s base salary (per hour) and the number of minutes worked on that day. On the five weekdays, any time worked in excess of a normal shift generates overtime pay; on the two weekend days, all work generates overtime pay. With a switch statement, it&#x2019;s easy to do this calculation by applying multiple case labels to each of two code fragments:</p>
<p>&#x7279;&#x5B9A;&#x5E38;&#x91CF;&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;&#x7684;&#x4E00;&#x4E2A;&#x7F3A;&#x70B9;&#x662F;&#xFF0C;&#x5B83;&#x4EEC;&#x4F7F;&#x5F97;&#x5728;&#x679A;&#x4E3E;&#x5E38;&#x91CF;&#x4E4B;&#x95F4;&#x5171;&#x4EAB;&#x4EE3;&#x7801;&#x53D8;&#x5F97;&#x66F4;&#x52A0;&#x56F0;&#x96BE;&#x3002;&#x4F8B;&#x5982;&#xFF0C;&#x8003;&#x8651;&#x4E00;&#x4E2A;&#x8868;&#x793A;&#x4E00;&#x5468;&#x5F53;&#x4E2D;&#x8BA1;&#x7B97;&#x5DE5;&#x8D44;&#x53D1;&#x653E;&#x7684;&#x679A;&#x4E3E;&#x3002;&#x679A;&#x4E3E;&#x6709;&#x4E00;&#x4E2A;&#x65B9;&#x6CD5;&#xFF0C;&#x8BE5;&#x65B9;&#x6CD5;&#x6839;&#x636E;&#x5DE5;&#x4EBA;&#x7684;&#x57FA;&#x672C;&#x5DE5;&#x8D44;&#xFF08;&#x6BCF;&#x5C0F;&#x65F6;&#xFF09;&#x548C;&#x5F53;&#x5929;&#x7684;&#x5DE5;&#x4F5C;&#x5206;&#x949F;&#x6570;&#x8BA1;&#x7B97;&#x5DE5;&#x4EBA;&#x5F53;&#x5929;&#x7684;&#x5DE5;&#x8D44;&#x3002;&#x5728;&#x4E94;&#x4E2A;&#x5DE5;&#x4F5C;&#x65E5;&#x5185;&#xFF0C;&#x4EFB;&#x4F55;&#x8D85;&#x8FC7;&#x6B63;&#x5E38;&#x8F6E;&#x73ED;&#x65F6;&#x95F4;&#x7684;&#x5DE5;&#x4F5C;&#x90FD;&#x4F1A;&#x4EA7;&#x751F;&#x52A0;&#x73ED;&#x8D39;&#xFF1B;&#x5728;&#x4E24;&#x4E2A;&#x5468;&#x672B;&#xFF0C;&#x6240;&#x6709;&#x7684;&#x5DE5;&#x4F5C;&#x90FD;&#x4F1A;&#x4EA7;&#x751F;&#x52A0;&#x73ED;&#x8D39;&#x3002;&#x4F7F;&#x7528; switch &#x8BED;&#x53E5;&#xFF0C;&#x901A;&#x8FC7;&#x591A;&#x4E2A; case &#x6807;&#x7B7E;&#x5E94;&#x7528;&#x4E8E;&#x6BCF;&#x4E00;&#x7C7B;&#x60C5;&#x51B5;&#xFF0C;&#x53EF;&#x4EE5;&#x5F88;&#x5BB9;&#x6613;&#x5730;&#x8FDB;&#x884C;&#x8BA1;&#x7B97;&#xFF1A;</p>
<pre><code>// Enum that switches on its value to share code - questionable
enum PayrollDay {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,SATURDAY, SUNDAY;

    private static final int MINS_PER_SHIFT = 8 * 60;

    int pay(int minutesWorked, int payRate) {
        int basePay = minutesWorked * payRate;
        int overtimePay;
        switch(this) {
            case SATURDAY:
            case SUNDAY: // Weekend
                overtimePay = basePay / 2;
                break;
            default: // Weekday
                overtimePay = minutesWorked &lt;= MINS_PER_SHIFT ?0 : (minutesWorked - MINS_PER_SHIFT) * payRate / 2;
        }
        return basePay + overtimePay;
    }
}
</code></pre><p><strong>&#x8BD1;&#x6CE8; 1&#xFF1A;&#x8BE5;&#x4F8B;&#x5B50;&#x4E2D;&#xFF0C;&#x52A0;&#x73ED;&#x7684;&#x6BCF;&#x5206;&#x949F;&#x5DE5;&#x8D44;&#x4E3A;&#x5DE5;&#x4F5C;&#x65E5;&#x6BCF;&#x5206;&#x949F;&#x5DE5;&#x8D44;&#xFF08;payRate&#xFF09;&#x7684;&#x4E00;&#x534A;</strong></p>
<p><strong>&#x8BD1;&#x6CE8; 2&#xFF1A;&#x539F;&#x6587;&#x4E2D; pay &#x65B9;&#x6CD5;&#x5B58;&#x5728;&#x95EE;&#x9898;&#xFF0C;&#x8BF4;&#x660E;&#x5982;&#x4E0B;&#xFF1A;</strong></p>
<pre><code>// &#x57FA;&#x672C;&#x5DE5;&#x8D44; basePay &#x4E0D;&#x5E94;&#x8BE5;&#x76F4;&#x63A5;&#x5C06;&#x5DE5;&#x4F5C;&#x65F6;&#x95F4;&#x53C2;&#x4E0E;&#x8BA1;&#x7B97;&#xFF0C;&#x5982;&#x679C;&#x5DE5;&#x4F5C;&#x65E5;&#x5B58;&#x5728;&#x52A0;&#x73ED;&#x7684;&#x60C5;&#x51B5;&#xFF0C;&#x4F1A;&#x5C06;&#x52A0;&#x73ED;&#x65F6;&#x95F4;&#x4E5F;&#x8BA1;&#x5165;&#x57FA;&#x672C;&#x5DE5;&#x8D44;&#x8BA1;&#x7B97;&#x3002;&#x5047;&#x8BBE;&#x5728;&#x5468;&#x4E00;&#x5DE5;&#x4F5C; 10 &#x5C0F;&#x65F6;&#xFF0C;&#x5047;&#x8BBE;&#x6BCF;&#x5206;&#x949F; 1 &#x5143;&#xFF1A;
/*
&#x4FEE;&#x6539;&#x524D;&#xFF1A;
    &#x57FA;&#x672C;&#x5DE5;&#x8D44; basePay = minutesWorked * payRate=10*60*1=600&#xFF08;&#x4E0D;&#x5E94;&#x8BE5;&#x5C06; 2 &#x5C0F;&#x65F6;&#x52A0;&#x73ED;&#x4E5F;&#x8BA1;&#x5165;&#x6B63;&#x5E38;&#x5DE5;&#x4F5C;&#x65F6;&#x95F4;&#xFF09;
    &#x52A0;&#x73ED;&#x5DE5;&#x8D44; overtimePay = (minutesWorked - MINS_PER_SHIFT) * payRate / 2=2*60*1/2=60
    &#x5408;&#x8BA1;= basePay + overtimePay=660
&#x4FEE;&#x6539;&#x540E;&#xFF1A;
    &#x57FA;&#x672C;&#x5DE5;&#x8D44; basePay = MINS_PER_SHIFT * payRate=8*60*1=480&#xFF08;&#x57FA;&#x672C;&#x5DE5;&#x8D44;&#x6700;&#x9AD8;&#x53EA;&#x80FD;&#x6309;&#x7167; 8 &#x5C0F;&#x65F6;&#x8BA1;&#x7B97;&#xFF09;
    &#x52A0;&#x73ED;&#x5DE5;&#x8D44; overtimePay = (minutesWorked - MINS_PER_SHIFT) * payRate / 2=2*60*1/2=60
    &#x5408;&#x8BA1;= basePay + overtimePay=540
*/
// &#x4FEE;&#x6539;&#x540E;&#x4EE3;&#x7801;&#xFF1A;
int pay(int minutesWorked, int payRate) {
    int basePay = 0;
    int overtimePay;
    switch (this) {
        case SATURDAY:
        case SUNDAY: // Weekend
            overtimePay = minutesWorked * payRate / 2;
            break;
        default: // Weekday
            basePay = minutesWorked &lt;= MINS_PER_SHIFT ? minutesWorked * payRate : MINS_PER_SHIFT * payRate;
            overtimePay = minutesWorked &lt;= MINS_PER_SHIFT ? 0 : (minutesWorked - MINS_PER_SHIFT) * payRate / 2;
    }
    return basePay + overtimePay;
}
</code></pre><p>This code is undeniably concise, but it is dangerous from a maintenance perspective. Suppose you add an element to the enum, perhaps a special value to represent a vacation day, but forget to add a corresponding case to the switch statement. The program will still compile, but the pay method will silently pay the worker the same amount for a vacation day as for an ordinary weekday.</p>
<p>&#x4E0D;&#x53EF;&#x5426;&#x8BA4;&#xFF0C;&#x8FD9;&#x6BB5;&#x4EE3;&#x7801;&#x975E;&#x5E38;&#x7B80;&#x6D01;&#xFF0C;&#x4F46;&#x662F;&#x4ECE;&#x7EF4;&#x62A4;&#x7684;&#x89D2;&#x5EA6;&#x6765;&#x770B;&#xFF0C;&#x5B83;&#x662F;&#x5371;&#x9669;&#x7684;&#x3002;&#x5047;&#x8BBE;&#x4F60;&#x5411;&#x679A;&#x4E3E;&#x4E2D;&#x6DFB;&#x52A0;&#x4E86;&#x4E00;&#x4E2A;&#x5143;&#x7D20;&#xFF0C;&#x53EF;&#x80FD;&#x662F;&#x4E00;&#x4E2A;&#x8868;&#x793A;&#x5047;&#x671F;&#x7684;&#x7279;&#x6B8A;&#x503C;&#xFF0C;&#x4F46;&#x662F;&#x5FD8;&#x8BB0;&#x5411; switch &#x8BED;&#x53E5;&#x6DFB;&#x52A0;&#x76F8;&#x5E94;&#x7684; case&#x3002;&#x8FD9;&#x4E2A;&#x7A0B;&#x5E8F;&#x4ECD;&#x7136;&#x4F1A;&#x88AB;&#x7F16;&#x8BD1;&#xFF0C;&#x4F46;&#x662F; pay &#x65B9;&#x6CD5;&#x4F1A;&#x628A;&#x5047;&#x671F;&#x9ED8;&#x8BA4;&#x5F53;&#x505A;&#x666E;&#x901A;&#x5DE5;&#x4F5C;&#x65E5;&#x5E76;&#x652F;&#x4ED8;&#x5DE5;&#x8D44;&#x3002;</p>
<p>To perform the pay calculation safely with constant-specific method implementations, you would have to duplicate the overtime pay computation for each constant, or move the computation into two helper methods, one for weekdays and one for weekend days, and invoke the appropriate helper method from each constant. Either approach would result in a fair amount of boilerplate code, substantially reducing readability and increasing the opportunity for error.</p>
<p>&#x4E3A;&#x4E86;&#x4F7F;&#x7528;&#x7279;&#x5B9A;&#x5E38;&#x91CF;&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;&#x5B89;&#x5168;&#x5730;&#x6267;&#x884C;&#x5DE5;&#x8D44;&#x8BA1;&#x7B97;&#xFF0C;&#x4F60;&#x5FC5;&#x987B;&#x4E3A;&#x6BCF;&#x4E2A;&#x5E38;&#x91CF;&#x590D;&#x5236;&#x52A0;&#x73ED;&#x8D39;&#x8BA1;&#x7B97;&#xFF0C;&#x6216;&#x8005;&#x5C06;&#x8BA1;&#x7B97;&#x79FB;&#x52A8;&#x5230;&#x4E24;&#x4E2A;&#x8F85;&#x52A9;&#x65B9;&#x6CD5;&#x4E2D;&#xFF0C;&#x4E00;&#x4E2A;&#x7528;&#x4E8E;&#x5DE5;&#x4F5C;&#x65E5;&#xFF0C;&#x4E00;&#x4E2A;&#x7528;&#x4E8E;&#x5468;&#x672B;&#xFF0C;&#x518D;&#x4ECE;&#x6BCF;&#x4E2A;&#x5E38;&#x91CF;&#x8C03;&#x7528;&#x9002;&#x5F53;&#x7684;&#x8F85;&#x52A9;&#x65B9;&#x6CD5;&#x3002;&#x4EFB;&#x4F55;&#x4E00;&#x79CD;&#x65B9;&#x6CD5;&#x90FD;&#x4F1A;&#x5BFC;&#x81F4;&#x76F8;&#x5F53;&#x6570;&#x91CF;&#x7684;&#x6837;&#x677F;&#x4EE3;&#x7801;&#xFF0C;&#x6781;&#x5927;&#x5730;&#x964D;&#x4F4E;&#x53EF;&#x8BFB;&#x6027;&#x5E76;&#x589E;&#x52A0;&#x51FA;&#x9519;&#x7684;&#x673A;&#x4F1A;&#x3002;</p>
<p>The boilerplate could be reduced by replacing the abstract overtimePay method on PayrollDay with a concrete method that performs the overtime calculation for weekdays. Then only the weekend days would have to override the method. But this would have the same disadvantage as the switch statement: if you added another day without overriding the overtimePay method, you would silently inherit the weekday calculation.</p>
<p>&#x7528;&#x5DE5;&#x4F5C;&#x65E5;&#x52A0;&#x73ED;&#x8BA1;&#x7B97;&#x7684;&#x5177;&#x4F53;&#x65B9;&#x6CD5;&#x4EE3;&#x66FF;&#x53D1;&#x85AA;&#x65E5;&#x7684;&#x62BD;&#x8C61;&#x52A0;&#x73ED;&#x6CD5;&#xFF0C;&#x53EF;&#x4EE5;&#x51CF;&#x5C11;&#x6837;&#x677F;&#x3002;&#x90A3;&#x4E48;&#x53EA;&#x6709;&#x5468;&#x672B;&#x624D;&#x9700;&#x8981;&#x91CD;&#x5199;&#x8BE5;&#x65B9;&#x6CD5;&#x3002;&#x4F46;&#x662F;&#x8FD9;&#x4E0E; switch &#x8BED;&#x53E5;&#x5177;&#x6709;&#x76F8;&#x540C;&#x7684;&#x7F3A;&#x70B9;&#xFF1A;&#x5982;&#x679C;&#x4F60;&#x5728;&#x4E0D;&#x8986;&#x76D6; overtimePay &#x65B9;&#x6CD5;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x6DFB;&#x52A0;&#x4E86;&#x53E6;&#x4E00;&#x5929;&#xFF0C;&#x90A3;&#x4E48;&#x4F60;&#x5C06;&#x9ED8;&#x9ED8;&#x5730;&#x7EE7;&#x627F;&#x5DE5;&#x4F5C;&#x65E5;&#x7684;&#x8BA1;&#x7B97;&#x3002;</p>
<p>What you really want is to be forced to choose an overtime pay strategy each time you add an enum constant. Luckily, there is a nice way to achieve this. The idea is to move the overtime pay computation into a private nested enum, and to pass an instance of this strategy enum to the constructor for the PayrollDay enum. The PayrollDay enum then delegates the overtime pay calculation to the strategy enum, eliminating the need for a switch statement or constantspecific method implementation in PayrollDay. While this pattern is less concise than the switch statement, it is safer and more flexible:</p>
<p>&#x4F60;&#x771F;&#x6B63;&#x60F3;&#x8981;&#x7684;&#x662F;&#x5728;&#x6BCF;&#x6B21;&#x6DFB;&#x52A0;&#x679A;&#x4E3E;&#x5E38;&#x91CF;&#x65F6;&#x88AB;&#x8FEB;&#x9009;&#x62E9;&#x52A0;&#x73ED;&#x8D39;&#x7B56;&#x7565;&#x3002;&#x5E78;&#x8FD0;&#x7684;&#x662F;&#xFF0C;&#x6709;&#x4E00;&#x4E2A;&#x5F88;&#x597D;&#x7684;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x5B9E;&#x73B0;&#x8FD9;&#x4E00;&#x70B9;&#x3002;&#x5176;&#x601D;&#x60F3;&#x662F;&#x5C06;&#x52A0;&#x73ED;&#x8D39;&#x8BA1;&#x7B97;&#x79FB;&#x5230;&#x79C1;&#x6709;&#x5D4C;&#x5957;&#x679A;&#x4E3E;&#x4E2D;&#xFF0C;&#x5E76;&#x5C06;&#x6B64;&#x7B56;&#x7565;&#x679A;&#x4E3E;&#x7684;&#x5B9E;&#x4F8B;&#x4F20;&#x9012;&#x7ED9; PayrollDay &#x679A;&#x4E3E;&#x7684;&#x6784;&#x9020;&#x51FD;&#x6570;&#x3002;&#x7136;&#x540E; PayrollDay &#x679A;&#x4E3E;&#x5C06;&#x52A0;&#x73ED;&#x8D39;&#x8BA1;&#x7B97;&#x59D4;&#x6258;&#x7ED9;&#x7B56;&#x7565;&#x679A;&#x4E3E;&#xFF0C;&#x4ECE;&#x800C;&#x6D88;&#x9664;&#x4E86;&#x5728; PayrollDay &#x4E2D;&#x4F7F;&#x7528; switch &#x8BED;&#x53E5;&#x6216;&#x7279;&#x5B9A;&#x4E8E;&#x5E38;&#x91CF;&#x7684;&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;&#x7684;&#x9700;&#x8981;&#x3002;&#x867D;&#x7136;&#x8FD9;&#x79CD;&#x6A21;&#x5F0F;&#x4E0D;&#x5982; switch &#x8BED;&#x53E5;&#x7B80;&#x6D01;&#xFF0C;&#x4F46;&#x5B83;&#x66F4;&#x5B89;&#x5168;&#xFF0C;&#x4E5F;&#x66F4;&#x7075;&#x6D3B;&#xFF1A;</p>
<pre><code>// The strategy enum pattern
enum PayrollDay {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND);

    private final PayType payType;
    PayrollDay(PayType payType) { this.payType = payType; }
    PayrollDay() { this(PayType.WEEKDAY); } // Default

    int pay(int minutesWorked, int payRate) {
        return payType.pay(minutesWorked, payRate);
    }

    // The strategy enum type
    private enum PayType {
        WEEKDAY {
            int overtimePay(int minsWorked, int payRate) {
                return minsWorked &lt;= MINS_PER_SHIFT ? 0 :(minsWorked - MINS_PER_SHIFT) * payRate / 2;
            }
        },
        WEEKEND {
            int overtimePay(int minsWorked, int payRate) {
                return minsWorked * payRate / 2;
            }
        };

        abstract int overtimePay(int mins, int payRate);

        private static final int MINS_PER_SHIFT = 8 * 60;

        int pay(int minsWorked, int payRate) {
            int basePay = minsWorked * payRate;
            return basePay + overtimePay(minsWorked, payRate);
        }
    }
}
</code></pre><p><strong>&#x8BD1;&#x6CE8;&#xFF1A;&#x4E0A;&#x8FF0;&#x4EE3;&#x7801; pay &#x65B9;&#x6CD5;&#x4E5F;&#x5B58;&#x5C06;&#x52A0;&#x73ED;&#x65F6;&#x95F4;&#x8BA1;&#x5165;&#x57FA;&#x672C;&#x5DE5;&#x8D44;&#x8BA1;&#x7B97;&#x7684;&#x95EE;&#x9898;&#xFF0C;&#x4FEE;&#x6539;&#x5982;&#x4E0B;&#xFF1A;</strong></p>
<pre><code>int pay(int minsWorked, int payRate) {
    int basePay = minsWorked &lt;= MINS_PER_SHIFT ? minsWorked * payRate : MINS_PER_SHIFT * payRate;
    return basePay + overtimePay(minsWorked, payRate);
}
</code></pre><p>If switch statements on enums are not a good choice for implementing constant-specific behavior on enums, what are they good for? <strong>Switches on enums are good for augmenting enum types with constant-specific behavior.</strong> For example, suppose the Operation enum is not under your control and you wish it had an instance method to return the inverse of each operation. You could simulate the effect with the following static method:</p>
<p>&#x5982;&#x679C;&#x5728;&#x679A;&#x4E3E;&#x4E0A;&#x5B9E;&#x73B0;&#x7279;&#x5B9A;&#x5E38;&#x91CF;&#x7684;&#x884C;&#x4E3A;&#x65F6; switch &#x8BED;&#x53E5;&#x4E0D;&#x662F;&#x4E00;&#x4E2A;&#x597D;&#x7684;&#x9009;&#x62E9;&#xFF0C;&#x90A3;&#x4E48;&#x5B83;&#x4EEC;&#x6709;&#x4EC0;&#x4E48;&#x7528;&#x5462;&#xFF1F;<strong>&#x679A;&#x4E3E;&#x4E2D;&#x7684; switch &#x6709;&#x5229;&#x4E8E;&#x6269;&#x5C55;&#x5177;&#x6709;&#x7279;&#x5B9A;&#x5E38;&#x91CF;&#x884C;&#x4E3A;&#x7684;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x3002;</strong> &#x4F8B;&#x5982;&#xFF0C;&#x5047;&#x8BBE; Operation &#x679A;&#x4E3E;&#x4E0D;&#x5728;&#x4F60;&#x7684;&#x63A7;&#x5236;&#x4E4B;&#x4E0B;&#xFF0C;&#x4F60;&#x5E0C;&#x671B;&#x5B83;&#x6709;&#x4E00;&#x4E2A;&#x5B9E;&#x4F8B;&#x65B9;&#x6CD5;&#x6765;&#x8FD4;&#x56DE;&#x6BCF;&#x4E2A;&#x64CD;&#x4F5C;&#x7684;&#x9006;&#x64CD;&#x4F5C;&#x3002;&#x4F60;&#x53EF;&#x4EE5;&#x7528;&#x4EE5;&#x4E0B;&#x9759;&#x6001;&#x65B9;&#x6CD5;&#x6A21;&#x62DF;&#x6548;&#x679C;&#xFF1A;</p>
<pre><code>// Switch on an enum to simulate a missing method
public static Operation inverse(Operation op) {
    switch(op) {
        case PLUS: return Operation.MINUS;
        case MINUS: return Operation.PLUS;
        case TIMES: return Operation.DIVIDE;
        case DIVIDE: return Operation.TIMES;
        default: throw new AssertionError(&quot;Unknown op: &quot; + op);
    }
}
</code></pre><p>You should also use this technique on enum types that are under your control if a method simply doesn&#x2019;t belong in the enum type. The method may be required for some use but is not generally useful enough to merit inclusion in the enum type.</p>
<p>&#x5982;&#x679C;&#x4E00;&#x4E2A;&#x65B9;&#x6CD5;&#x4E0D;&#x5C5E;&#x4E8E;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#xFF0C;&#x90A3;&#x4E48;&#x8FD8;&#x5E94;&#x8BE5;&#x5728;&#x4F60;&#x63A7;&#x5236;&#x7684;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x4E0A;&#x4F7F;&#x7528;&#x8FD9;&#x79CD;&#x6280;&#x672F;&#x3002;&#x8BE5;&#x65B9;&#x6CD5;&#x53EF;&#x80FD;&#x9002;&#x7528;&#x4E8E;&#x67D0;&#x4E9B;&#x7279;&#x6B8A;&#x7528;&#x9014;&#xFF0C;&#x4F46;&#x901A;&#x5E38;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x8DB3;&#x591F;&#x7684;&#x597D;&#x5904;&#xFF0C;&#x5C31;&#x4E0D;&#x503C;&#x5F97;&#x5305;&#x542B;&#x5728;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x4E2D;&#x3002;</p>
<p>Enums are, generally speaking, comparable in performance to int constants. A minor performance disadvantage of enums is that there is a space and time cost to load and initialize enum types, but it is unlikely to be noticeable in practice.</p>
<p>&#x4E00;&#x822C;&#x6765;&#x8BF4;&#xFF0C;&#x679A;&#x4E3E;&#x5728;&#x6027;&#x80FD;&#x4E0A;&#x53EF;&#x4E0E; int &#x5E38;&#x91CF;&#x76F8;&#x6BD4;&#x3002;&#x679A;&#x4E3E;&#x5728;&#x6027;&#x80FD;&#x4E0A;&#x6709;&#x4E00;&#x4E2A;&#x5C0F;&#x7F3A;&#x70B9;&#xFF0C;&#x52A0;&#x8F7D;&#x548C;&#x521D;&#x59CB;&#x5316;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x9700;&#x8981;&#x82B1;&#x8D39;&#x7A7A;&#x95F4;&#x548C;&#x65F6;&#x95F4;&#xFF0C;&#x4F46;&#x662F;&#x5728;&#x5B9E;&#x9645;&#x5E94;&#x7528;&#x4E2D;&#x8FD9;&#x4E00;&#x70B9;&#x53EF;&#x80FD;&#x4E0D;&#x592A;&#x660E;&#x663E;&#x3002;</p>
<p>So when should you use enums? <strong>Use enums any time you need a set of constants whose members are known at compile time.</strong> Of course, this includes &#x201C;natural enumerated types,&#x201D; such as the planets, the days of the week, and the chess pieces. But it also includes other sets for which you know all the possible values at compile time, such as choices on a menu, operation codes, and command line flags. <strong>It is not necessary that the set of constants in an enum type stay fixed for all time.</strong> The enum feature was specifically designed to allow for binary compatible evolution of enum types.</p>
<p>&#x90A3;&#x4E48;&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x5E94;&#x8BE5;&#x4F7F;&#x7528;&#x679A;&#x4E3E;&#x5462;&#xFF1F;<strong>&#x5728;&#x9700;&#x8981;&#x4E00;&#x7EC4;&#x5E38;&#x91CF;&#x65F6;&#x4F7F;&#x7528;&#x679A;&#x4E3E;&#xFF0C;&#x8FD9;&#x4E9B;&#x5E38;&#x91CF;&#x7684;&#x6210;&#x5458;&#x5728;&#x7F16;&#x8BD1;&#x65F6;&#x662F;&#x5DF2;&#x77E5;&#x7684;&#x3002;</strong> &#x5F53;&#x7136;&#xFF0C;&#x8FD9;&#x5305;&#x62EC;&#x300C;&#x81EA;&#x7136;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x300D;&#xFF0C;&#x5982;&#x884C;&#x661F;&#x3001;&#x661F;&#x671F;&#x51E0;&#x548C;&#x68CB;&#x5B50;&#x3002;&#x4F46;&#x662F;&#x5B83;&#x8FD8;&#x5305;&#x62EC;&#x5176;&#x4ED6;&#x5728;&#x7F16;&#x8BD1;&#x65F6;&#x5DF2;&#x77E5;&#x6240;&#x6709;&#x53EF;&#x80FD;&#x503C;&#x7684;&#x96C6;&#x5408;&#xFF0C;&#x4F8B;&#x5982;&#x83DC;&#x5355;&#x4E0A;&#x7684;&#x9009;&#x9879;&#x3001;&#x64CD;&#x4F5C;&#x4EE3;&#x7801;&#x548C;&#x547D;&#x4EE4;&#x884C;&#x6807;&#x5FD7;&#x3002;<strong>&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x4E2D;&#x7684;&#x5E38;&#x91CF;&#x96C6;&#x6CA1;&#x6709;&#x5FC5;&#x8981;&#x4E00;&#x76F4;&#x4FDD;&#x6301;&#x56FA;&#x5B9A;&#x3002;</strong> &#x679A;&#x4E3E;&#x7684;&#x7279;&#x6027;&#x662F;&#x4E13;&#x95E8;&#x4E3A;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x7684;&#x4E8C;&#x8FDB;&#x5236;&#x517C;&#x5BB9;&#x8FDB;&#x5316;&#x800C;&#x8BBE;&#x8BA1;&#x7684;&#x3002;</p>
<p>In summary, the advantages of enum types over int constants are compelling. Enums are more readable, safer, and more powerful. Many enums require no explicit constructors or members, but others benefit from associating data with each constant and providing methods whose behavior is affected by this data. Fewer enums benefit from associating multiple behaviors with a single method. In this relatively rare case, prefer constant-specific methods to enums that switch on their own values. Consider the strategy enum pattern if some, but not all, enum constants share common behaviors.</p>
<p>&#x603B;&#x4E4B;&#xFF0C;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x76F8;&#x5BF9;&#x4E8E; int &#x5E38;&#x91CF;&#x7684;&#x4F18;&#x52BF;&#x662F;&#x6BCB;&#x5EB8;&#x7F6E;&#x7591;&#x7684;&#x3002;&#x679A;&#x4E3E;&#x66F4;&#x6613;&#x4E8E;&#x9605;&#x8BFB;&#x3001;&#x66F4;&#x5B89;&#x5168;&#x3001;&#x66F4;&#x5F3A;&#x5927;&#x3002;&#x8BB8;&#x591A;&#x679A;&#x4E3E;&#x4E0D;&#x9700;&#x8981;&#x663E;&#x5F0F;&#x6784;&#x9020;&#x51FD;&#x6570;&#x6216;&#x6210;&#x5458;&#xFF0C;&#x4F46;&#x6709;&#x4E9B;&#x679A;&#x4E3E;&#x5219;&#x53D7;&#x76CA;&#x4E8E;&#x5C06;&#x6570;&#x636E;&#x4E0E;&#x6BCF;&#x4E2A;&#x5E38;&#x91CF;&#x5173;&#x8054;&#xFF0C;&#x5E76;&#x63D0;&#x4F9B;&#x884C;&#x4E3A;&#x53D7;&#x6570;&#x636E;&#x5F71;&#x54CD;&#x7684;&#x65B9;&#x6CD5;&#x3002;&#x5C06;&#x591A;&#x4E2A;&#x884C;&#x4E3A;&#x4E0E;&#x4E00;&#x4E2A;&#x65B9;&#x6CD5;&#x5173;&#x8054;&#x8D77;&#x6765;&#xFF0C;&#x8FD9;&#x6837;&#x7684;&#x679A;&#x4E3E;&#x66F4;&#x5C11;&#x3002;&#x5728;&#x8FD9;&#x79CD;&#x76F8;&#x5BF9;&#x5C11;&#x89C1;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x76F8;&#x5BF9;&#x4E8E;&#x4F7F;&#x7528; switch &#x7684;&#x679A;&#x4E3E;&#xFF0C;&#x7279;&#x5B9A;&#x5E38;&#x91CF;&#x65B9;&#x6CD5;&#x66F4;&#x597D;&#x3002;&#x5982;&#x679C;&#x679A;&#x4E3E;&#x5E38;&#x91CF;&#x6709;&#x4E00;&#x4E9B;&#xFF08;&#x4F46;&#x4E0D;&#x662F;&#x5168;&#x90E8;&#xFF09;&#x5171;&#x4EAB;&#x516C;&#x5171;&#x884C;&#x4E3A;&#xFF0C;&#x8BF7;&#x8003;&#x8651;&#x7B56;&#x7565;&#x679A;&#x4E3E;&#x6A21;&#x5F0F;&#x3002;</p>
<hr>
<p><strong><a href="Chapter-6-Introduction.html">Back to contents of the chapter&#xFF08;&#x8FD4;&#x56DE;&#x7AE0;&#x8282;&#x76EE;&#x5F55;&#xFF09;</a></strong></p>
<ul>
<li><strong>Next Item&#xFF08;&#x4E0B;&#x4E00;&#x6761;&#x76EE;&#xFF09;&#xFF1A;<a href="Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals.html">Item 35: Use instance fields instead of ordinals&#xFF08;&#x4F7F;&#x7528;&#x5B9E;&#x4F8B;&#x5B57;&#x6BB5;&#x66FF;&#x4EE3;&#x5E8F;&#x6570;&#xFF09;</a></strong></li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Chapter-6-Introduction.html" class="navigation navigation-prev " aria-label="Previous page: Chapter 6 Introduction（章节介绍）">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals.html" class="navigation navigation-next " aria-label="Next page: Item 35: Use instance fields instead of ordinals（使用实例字段替代序数）">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Item 34: Use enums instead of int constants（用枚举类型代替 int 常量）","level":"1.6.2","depth":2,"next":{"title":"Item 35: Use instance fields instead of ordinals（使用实例字段替代序数）","level":"1.6.3","depth":2,"path":"Chapter-6/Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals.md","ref":"Chapter-6/Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals.md","articles":[]},"previous":{"title":"Chapter 6 Introduction（章节介绍）","level":"1.6.1","depth":2,"path":"Chapter-6/Chapter-6-Introduction.md","ref":"Chapter-6/Chapter-6-Introduction.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md","mtime":"2021-12-19T09:10:38.056Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2021-12-19T10:16:38.761Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

